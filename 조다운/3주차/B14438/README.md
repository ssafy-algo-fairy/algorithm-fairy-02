<!-- @format -->

### 문제 요약

특정 인덱스의 값을 갱신하고, 주어진 구간 $[i, j]$ 내에서 최솟값을 효율적으로 구한다.

### 문제 접근

1. 처음에는 brute force 로 접근했다.
2. 시간 초과가 나서 헤매다가 세그먼트 트리를 학습하고 적용하여 해결했다.

### 처음 시간 초과 난 이유

#### 1. 시간 복잡도 계산

- 1번 쿼리 (update): `A[i] = v` 는 **O(1)**
- 2번 쿼리 (구간 최솟값): for문을 돌며 $i$부터 $j$ 까지 확인, 최악의 경우(구간이 $1$부터 $N$까지일 때) $O(N)$이 소요

#### 2. 문제 제약 조건

- $N = 100,000$ (수열의 크기)
- $M = 100,000$ (쿼리의 개수)
- $M \times N = 10,000,000,000$ (100억 번의 연산)

#### 3. 결론

단순 반복문으로 구간 최솟값을 찾을 경우, 하나의 쿼리당 $O(N)$의 시간이 소요. $N$과 $M$이 각각 10만일 때, 최대 연산 횟수는 100억 번에 달하여 시간 제한(보통 1~2초)을 초과하게 된다. 따라서 세그먼트 트리를 이용하여 갱신과 조회를 모두 $O(\log N)$으로 처리해야 한다.

### 핵심 코드

#### 트리 초기화 (init)

```java
static int init(int s, int e, int node) {
    // 리프 노드에 도달했을 때
    if (s == e) {
        return tree[node] = A[s];
    }
    int mid = (s + e) / 2;

    // 왼쪽 자식(node*2)과 오른쪽 자식(node*2+1) 중 작은 값을 저장
    return tree[node] = Math.min(init(s, mid, node * 2), init(mid + 1, e, node * 2 + 1));
}
```

#### 트리 값 갱신 1번 쿼리 (update)

```java
static int update(int s, int e, int node, int i, int v) {
    // 수정하려는 인덱스가 현재 구간 밖에 있다면 기존 값 유지
    if (i < s || i > e)
        return tree[node];

    // 리프 노드에 도달하면 값을 변경
    if (s == e)
        return tree[node] = v;

    int mid = (s + e) / 2;

    // 1. mid 부터
    return tree[node] = Math.min(update(s, mid, node * 2, i, v), update(mid + 1, e, node * 2 + 1, i, v));
}
```

#### 구간 최소값 찾기 2번 쿼리 (query)

```java
static int query(int s, int e, int node, int i, int j) {
    // 탐색 범위가 퀴리 범위를 완전히 벗어난 경우
    if (i > e || j < s)
        return Integer.MAX_VALUE;

    // 탐색 범위가 퀴리 범위 안에 완전히 포함된 경우
    if (i <= s && e <= j)
        return tree[node];

    int mid = (s + e) / 2;

    return Math.min(query(s, mid, node * 2, i, j), query(mid + 1, e, node * 2 + 1, i, j));
}

```

### 세그먼트 트리 쓰는 이유

- 데이터의 개수(N)와 쿼리의 개수(M)가 모두 10^5 이상이다. (일반 반복문으로는 불가능)
- 중간에 값이 계속 바뀐다. (누적 합 Prefix Sum을 쓰지 못하는 이유)
- 특정 범위 [i, j] 에 대한 결과값을 요구한다.

| **비교 항목** | **Brute-Force**        | **세그먼트 트리**           |
| ------------- | ---------------------- | --------------------------- |
| 갱신 (Update) | $O(1)$                 | $O(\log N)$                 |
| 조회 (Query)  | **$O(N)$** (매우 느림) | **$O(\log N)$** (매우 빠름) |
| 전체 복잡도   | $O(MN)$                | $O(M \log N)$               |

### 세그먼트 트리 유형 문제 힌트

- 배열의 i 번째 수를 v 로 바꾼다. (update)
- 특정 구간의 ~ 를 구해라.
- 이러한 연산이 M 번 반복된다. (보통 N 과 M 이 10^5 10만 수준으로 주어진다.)
- 값이 수시로 변하는 동적인 수열

### 느낀 점

세그먼트 트리를 내가 어떻게 알지... 세그먼트 트리가 뭔지를 알려주고 쓰라고 해야지 뭔지도 안 알려주고 이런 문제를 내면 내가 문제를 어떻게 풀지 라고 23시간 생각하면서 의재 님 원망하다가 어차피 모르는 거 이제 공부해서 써먹어야겠다고 마음 먹고 공부하였습니다.
