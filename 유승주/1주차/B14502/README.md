# 백준 14502번 - 연구소

<aside>

## 📘 학습한 내용

완전 탐색(Brute Force)과 DFS를 활용한 시뮬레이션 문제 해결

</aside>

## 📝 문제 요약

> **상황**: N×M 크기의 연구소에서 바이러스가 확산되는 것을 막기  
**조건**: 정확히 **3개의 벽**을 세워야 함 (빈 칸에만 설치 가능)  
**목표**: 바이러스 확산 후 남은 안전 영역의 **최댓값** 구하기

---

## 💡 1. 나의 접근 방식 & 핵심 아이디어

- **알고리즘/자료구조: 완전 탐색 (Combination) + DFS (깊이 우선 탐색)**
- **시간/공간 복잡도:**
  - **시간:** `O(C(빈칸, 3) × N×M)` ≈ `O(64³ × 64)` (최악의 경우)
  - **공간:** `O(N×M)` (지도 + visited 배열)
- **핵심 로직:**
  1. **3중 for문으로 벽 3개의 모든 조합 생성**: 빈 칸 리스트에서 3개를 선택하는 조합 구현
  2. **map 배열 직접 수정**: 벽 설치 → 바이러스 확산 → 벽 복구 과정을 통해 시뮬레이션
  3. **DFS로 바이러스 확산**: 각 바이러스 위치에서 상하좌우로 재귀 탐색하며 감염 칸 수 계산
  4. **안전 영역 계산**: `(전체 빈 칸 수 - 3) - 감염된 칸 수`

---

## ✨ 2. 나의 최종 코드

### 핵심 로직 코드

```java
// 1. 완전 탐색: 3개의 벽 조합 생성
for(int i = 0; i < zeroNum - 2; i++){
    for(int j = i + 1; j < zeroNum - 1; j++){
        for(int k = j + 1; k < zeroNum; k++){
            // 3개의 벽 위치 선택 후 시뮬레이션
            maxRes = Math.max(maxRes, calculateSafeArea(walls));
        }
    }
}

// 2. map 배열 직접 수정을 통한 시뮬레이션
// 벽 설치
for(Point wall : walls) map[wall.y][wall.x] = 1;

// 바이러스 확산
for(Point virus : virusList) totalInfected += dfs(virus.x, virus.y, visited);

// 벽 복구 (다음 시뮬레이션을 위해)
for(Point wall : walls) map[wall.y][wall.x] = 0;
```

---

## 🤔 3. 문제 회고 (Retrospective)

### 🐾 3-1. 오류 해결 과정 (Troubleshooting Log)

#### **Issue 1: Point 객체 비교 문제 (equals/hashCode 미구현)**
- **현상**: 처음에는 벽 위치를 체크하기 위해 `walls.contains(new Point(nx, ny))` 방식을 사용하려 했으나, 항상 `false`를 반환함.
- **원인**: Point 클래스에 `equals()`와 `hashCode()`를 오버라이드하지 않아서, 객체 참조값으로 비교되어 동일한 좌표임에도 다른 객체로 판단됨.
- **시도했던 방법들**:
  1. `equals()`/`hashCode()` 구현 → 코드가 복잡해짐
  2. HashSet으로 O(1) 체크 → 여전히 equals 문제
- **최종 해결**: **map 배열을 직접 수정**하는 방식으로 전환. 벽을 설치할 때 `map[y][x] = 1`로 표시하고, DFS에서 `map[ny][nx] == 0` 조건으로 체크. 이렇게 하면 객체 비교 없이 O(1)로 확인 가능.

```java
// ❌ 이전 방식: contains 사용 (동작하지 않음)
if(walls.contains(new Point(nx, ny))) continue;

// ✅ 개선된 방식: map 배열 직접 수정
for(Point wall : walls) map[wall.y][wall.x] = 1;  // 벽 설치
// ... DFS 수행 ...
for(Point wall : walls) map[wall.y][wall.x] = 0;  // 벽 복구
```

#### **Issue 2: 모든 테스트 케이스에서 -3 출력**
- **현상**: 예제 입력에 대해 항상 `-3`이라는 이상한 값이 출력됨.
- **원인**: `calculateSafeArea()` 함수에서 **벽을 설치하는 코드가 주석만 있고 실제 구현이 누락**됨. 벽이 없으니 모든 빈 칸(zeroNum)이 감염되어 `(zeroNum - 3) - zeroNum = -3`이 됨.
- **깨달음**: 주석만 작성하고 실제 코드를 작성하지 않은 실수. **구현 직후 바로 테스트**하는 습관이 중요함을 배움.

```java
// ❌ 이전 코드: 주석만 있고 구현 없음
static int calculateSafeArea(List<Point> walls){
    int safeArea = zeroNum - 3;
    
    // 벽 위치를 map에 표시  <- 주석만 있음!
    
    // 바이러스 확산...
}

// ✅ 수정 후: 실제 구현 추가
for(Point wall : walls){
    map[wall.y][wall.x] = 1;
}
```

#### **Issue 3: 성능 개선 고민**
- **고민 과정**: 
  - 처음엔 매번 `new boolean[N][M]`로 visited 배열을 생성해서 메모리 오버헤드가 있었음
  - 전역 배열로 빼고 재사용하는 것도 고려했으나, 초기화 비용이 생김
  - 최종적으로는 **백준 채점 환경에서 충분히 빠르므로** 가독성을 위해 현재 방식 유지
- **배운 점**: 무조건적인 최적화보다는, **문제의 제약 조건을 보고 필요한 만큼만 최적화**하는 것이 중요.

---

### 🌱 3-2. 새롭게 알게 된 점 (Learning Points)

1. **시뮬레이션에서의 원상복구 패턴**
   - 상태를 변경하고, 탐색하고, 다시 복구하는 패턴이 완전 탐색에서 매우 유용함을 배움
   - 깊은 복사 대신 **직접 수정 + 복구**가 훨씬 효율적

2. **조합 구현의 다양한 방법**
   - 3중 for문: 간단하고 직관적 (고정된 개수일 때)
   - 재귀 + 백트래킹: 유연하고 확장 가능 (개수가 변할 때)
   - 이 문제에서는 벽이 정확히 3개로 고정이므로 3중 for문이 더 효율적

3. **DFS vs BFS 선택 기준**
   - 이 문제는 "모든 칸을 방문"하는 것이 목적이므로 DFS, BFS 모두 가능
   - DFS는 재귀로 구현이 간단하지만, 스택 오버플로우 위험이 있음
   - BFS는 큐를 사용해 안정적이지만 코드가 조금 더 길어짐

4. **입력 처리 최적화**
   - 입력을 받으면서 동시에 빈 칸과 바이러스 위치를 리스트에 저장
   - 나중에 다시 순회하지 않아도 되어 효율적

---

### 🧐 3-3. 더 궁금한 점 & 다음 목표 (Further Questions)

- **비트마스킹 최적화**: 방문 체크를 비트마스킹으로 하면 더 빠를까? (N, M이 작아서 효과가 미미할 것 같긴 함)
- **가지치기(Pruning)**: 현재 최댓값보다 이론적으로 더 큰 값이 나올 수 없는 경우를 미리 판단해 건너뛸 수 있을까?
- **BFS 구현 연습**: 같은 문제를 BFS로도 구현해보며 두 방식의 차이를 체감해보기
- **비슷한 유형 문제**: 벽을 세우는 대신 다른 조건을 변경하는 시뮬레이션 문제들 풀어보기

---
