## 📝 문제 요약

홍익대학교 투어

- N개의 구역이 원형으로 배치 ( 1이면 명소, 0이면 아님)
- 도현이의 현재 위치는 1번 구역
- 다음 쿼리 수행
    - 1 i : i번 구역이 명소가 아니었다면 명소로 지정되고, 명소였다면 지정이 풀리게 된다.
    - 2 x : 도현이가 시계방향으로 x만큼 이동한다.
    - 3 : 도현이가 명소에 도달하기 위해 시계방향으로 최소 몇 칸 움직여야 하는 지 출력한다. 명소가 존재하지 않는 경우 -1을 출력한다.

## 💡 접근 방법

- **알고리즘/자료구조:**
    
    `TreeSet` (균형 이진 탐색 트리)
    
- **핵심 아이디어:**
    
    관광지(`1`)의 위치만을 `TreeSet`에 저장하여 관리한다.
    
    현재 위치에서 다음 관광지를 찾을 때 배열을 순회하지 않고,
    
    `ceiling()`을 이용해 **현재 위치 이상에서 가장 가까운 관광지**를 즉시 찾는다.
    
    만약 없다면 원형 구조이므로 `first()`를 이용해 처음 위치로 돌아간다.
    

---

## ✅ 풀이 과정

### 1. 문제 분석

- 길은 원형 구조이며, 현재 위치에서 시계 방향으로 이동한다.
- 쿼리는 세 가지 종류로 구성된다.
    - 관광지 상태 토글
    - 현재 위치 이동
    - 다음 관광지까지의 거리 출력
- 단순 배열 탐색으로 다음 관광지를 찾으면 시간초과가 발생한다.

---

### 2. 해결 전략 수립

- `"1"`인 위치만 따로 관리하면 불필요한 탐색을 줄일 수 있다.
- `TreeSet`을 사용해 관광지 위치를 **정렬된 상태로 유지**한다.
- 다음 관광지 탐색 시
    - `ceiling(idx)`로 현재 위치 이상에서 가장 가까운 관광지 탐색
    - 없으면 원형 구조를 고려해 `first()` 사용

---

### 3. 코드 구현

- 초기 입력에서 관광지(`1`) 위치를 `TreeSet`에 저장
- 쿼리별 처리
    - **1번 쿼리:** 관광지 토글 → `add / remove`
    - **2번 쿼리:** 현재 위치 갱신 → 모듈러 연산
    - **3번 쿼리:** `ceiling / first`를 이용해 거리 계산

### TreeSet

: 균형 이진 탐색 트리, 항상 정렬된 상태 유지

→ 범위 탐색, 앞/뒤 값 찾기에 최강, 중복 허용 x

```java
TreeSet<Integer> set = new TreeSet<>();

//추가
set.add(3);
set.add(1);
set.add(5);
set.add(3); // 중복 → 무시

// 제거
set.remove(3);

// 포함여부
set.contains(1); // true

// x 이상 중 최소
set.ceiling(4) // 5

// x 초과 중 최소
set.ceiling(5) // 8

// x 이하 중 최대
set.floor(5) // 5

// x 미만 중 최대
set.lower(4) // 3

// 맨 앞
set.first();

// 맨 뒤
set.last();

// 원형 구조에서 자주 쓰는 패턴
Integer next = set.ceiling(idx);
if (next == null) {
    next = set.first(); // 원형 처리
}

// 정렬 기준
TreeSet<Integer> set = new TreeSet<>(Collections.reverseOrder());
TreeSet<String> set = new TreeSet<>(
    (a, b) -> a.length() - b.length()
);

```

### TreeSet 사용하면 좋은 문제 유형

✅ **이런 키워드 나오면 TreeSet 떠올려라**

- 다음 / 이전 값
- 가장 가까운 값
- 원형
- 범위 내 최소 / 최대
- 동적 삽입 + 탐색

❌ **이럴 땐 비추천**

- 단순 삽입 + 인덱스 접근 → `ArrayList`
- 순서만 유지 → `LinkedHashSet`
- 해시만 필요 → `HashSet`