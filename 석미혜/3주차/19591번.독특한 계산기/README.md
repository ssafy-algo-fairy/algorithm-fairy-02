## 이슈번호
Ref : #148

## 📝 문제 요약

형택이는 보드의 가장 왼쪽 위에 동전을 하나 올려놓는다.

동전을 위,아래,오른쪽,왼쪽 네방향으로 움직이며 동전이 있는 곳에 쓰여있는 숫자 만큼 움직인다.

‘H’는 구멍이며 이동중에 있는 구멍은 무시되고, 구멍에 도착하면 게임은 종료된다. ( 보드 바깥으로 나가도 종료) 이 게임을 오래하고싶다면 최대 몇번을 움직일 수 있는지 구하라 ( 무한번 움직일수있다면 -1)

## 💡 접근 방법

- **알고리즘/자료구조: DFS, DP**
- **핵심 아이디어: 그냥 DFS로 돌면 시간이 너무 많이 걸려서, 메모이제이션을 함께 사용**

## ✅ 풀이 과정

### 1. 문제 분석

BOJ 1103(게임) 문제는 `(0,0)`에서 시작해서 **현재 칸의 숫자만큼 상하좌우로 이동**하며,

이동 가능한 최대 횟수를 구하는 문제입니다.

- `H`는 구멍 → 더 이상 이동 불가 (게임 종료)
- 범위를 벗어나도 종료
- 만약 **같은 경로에서 같은 칸을 다시 방문**하게 되면 무한 루프이므로 정답은 `1`

즉, 이 문제의 핵심은 다음 2가지입니다.

1. **최대 이동 횟수 계산**
2. **무한 루프(사이클) 탐지**

---

### 2. 해결 전략 수립

이 코드는 **DFS + DP(메모이제이션) + 방문 배열(사이클 탐지)** 조합으로 해결합니다.

### (1) DFS로 최대 이동 횟수 탐색

`dfs(x, y)`를

→ **(x, y)에서 시작했을 때 이동할 수 있는 최대 횟수** 로 정의합니다.

현재 칸의 숫자를 `n`이라고 하면,

4방향으로 `n`칸씩 이동한 다음 결과 중 최댓값을 선택합니다.

`+1`은 현재 칸에서 한 번 이동한 횟수를 의미합니다.

---

### (2) 무한 루프 탐지 (visited 배열)

`visited[x][y]`는 **현재 DFS 경로(stack)** 상에서 방문 중인 칸인지 체크합니다.

- DFS 중 다시 `visited[x][y] == true`인 칸에 도달하면
    
    → 같은 경로에서 같은 칸 재방문 = **사이클 발생**
    
    → `infinite = true`로 표시
    

> 여기서 중요한 점은 `visited`가 단순 방문 체크가 아니라,
> 
> 
> **현재 재귀 호출 경로에서만 유효한 방문 체크**라는 점입니다.
> 
> 그래서 DFS 종료 후 `visited[x][y] = false`로 되돌려줍니다 (백트래킹).
> 

---

### (3) DP(메모이제이션)로 중복 계산 제거

같은 칸에서 시작하는 최대 이동 횟수는 항상 같으므로,

이미 계산한 값은 `dp[x][y]`에 저장해 재사용합니다.

이렇게 하면 중복 DFS를 줄여서 시간 초과를 방지할 수 있습니다.

---

### 3. 코드 구현

아래는 코드 흐름 기준으로 핵심 구현 포인트를 정리한 것입니다.

**(1) 입력 및 자료구조 초기화**

- `map`: 보드 정보 (`숫자` 또는 `H`)
- `visited`: 현재 DFS 경로 방문 여부 (사이클 탐지용)
- `dp`: 해당 칸에서 시작했을 때 최대 이동 횟수 저장

---

**(2) DFS 시작 및 결과 출력**

`dfs(0, 0)`으로 시작하고,

탐색 중 무한 루프가 발견되면 `-1` 출력, 아니면 최대 이동 횟수 출력

---

**(3) DFS 종료 조건 (기저 조건)**

범위를 벗어나거나 구멍(`H`)이면 더 이상 진행 불가 → `0` 반환

---

**(4) 사이클 탐지**

현재 경로에서 이미 방문 중인 칸을 다시 만나면 무한 루프

---

 **(5) DP 재사용**

이미 계산된 칸이면 그대로 반환

---

**(6) 4방향 탐색 + 최댓값 계산**

현재 칸 숫자만큼 점프하여 이동하고,

각 방향 결과 중 최댓값을 선택

---

**(7) 백트래킹 + DP 저장**

현재 경로 방문 해제 후, 계산 결과를 저장해서 반환

---