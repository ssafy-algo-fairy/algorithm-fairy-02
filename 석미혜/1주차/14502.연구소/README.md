## 📝 문제 요약

N×M 크기의 연구소가 주어지고, 각 칸은 빈 칸(0), 벽(1), 바이러스(2) 중 하나이다.

빈 칸 중 **3곳에 벽을 새로 세운 뒤**, 바이러스가 상하좌우로 퍼진다고 할 때

**바이러스가 퍼지지 않고 남아 있는 안전 영역의 최대 크기**를 구하는 문제이다.

## **💡 접근 방법**

- **알고리즘/자료구조:**

  조합(Combination), DFS(또는 BFS), 완전 탐색

- **핵심 아이디어:**
    1. 빈 칸 중에서 **벽을 세울 3곳을 모든 조합으로 선택**한다.
    2. 각 조합마다 벽을 세운 뒤, **바이러스를 확산시켜 시뮬레이션**한다.
    3. 확산이 끝난 후 **안전 영역(0)의 개수**를 세어 최댓값을 갱신한다.
- **시간 복잡도:**
    - 빈 칸 개수를 E라 하면
        - 벽 조합: O(E³)
        - 각 조합마다 DFS/BFS 확산: O(N×M)
    - 전체 시간 복잡도: **O(E³ × N × M)**

      (N, M ≤ 8 이므로 충분히 가능)

- **공간 복잡도:**
    - 연구소 복사 배열, 재귀 호출 스택 포함
    - **O(N × M)**

---

## **✅ 풀이 과정**

### **1. 문제 분석**

- 벽을 정확히 **3개만** 세울 수 있음
- 바이러스는 **상하좌우로만 확산**
- 모든 경우를 고려해야 하므로 **그리디 불가**
- 입력 크기가 작아 **완전 탐색 가능**

---

### **2. 해결 전략 수립**

1. 연구소에서 **빈 칸 좌표 목록**을 미리 저장
2. 빈 칸 중 **3개를 뽑는 모든 조합 생성**
3. 각 조합마다:
    - 기존 맵을 복사
    - 선택된 3칸에 벽 설치
    - 모든 바이러스 위치에서 DFS/BFS로 확산
4. 확산 후 남은 0의 개수로 안전 영역 계산
5. 최댓값 갱신

---

### **3. 코드 구현**

- 조합은 재귀로 구현 (comb(start, count))
- 바이러스 확산은 DFS 사용
- 매 시뮬레이션마다 맵을 **깊은 복사**해서 원본 보존
- 벽 좌표는 int[3][2] 형태로 관리하여 정확히 3개만 처리

---

### **4. 테스트 및 검증**

- 공식 예제 입력으로 정상 출력 확인
- 벽 위치가 겹치지 않는지 검증
- 바이러스가 모든 방향으로 확산되는지 확인
- 최대 안전 영역 값이 올바르게 갱신되는지 점검