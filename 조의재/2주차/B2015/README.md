# [BJ 2015] 수들의 합 4 - Java

### 📋 문제 개요
- **알고리즘 유형**: 누적 합 (Prefix Sum), 자료 구조 (HashMap)
- **문제 핵심**: $N$개의 정수로 이루어진 배열에서 부분합이 정확히 $K$가 되는 구간의 개수를 찾는 문제입니다. $N$이 최대 200,000이므로 $O(N^2)$ 탐색 시 시간 초과가 발생하며, HashMap을 이용한 **$O(N)$** 풀이가 권장됩니다.

---

### 💡 풀이 로직
1. **누적 합(Prefix Sum) 수식**: 
   - $i$번째부터 $j$번째까지의 부분합은 `S[j] - S[i-1]`입니다.
   - 우리가 찾는 조건은 `S[j] - S[i-1] = K`이며, 이를 변형하면 **`S[i-1] = S[j] - K`**가 됩니다.
2. **HashMap을 통한 효율적 탐색**: 
   - 배열을 한 번 순회하며 현재까지의 누적 합(`total`)을 구합니다.
   - 이때 `total - K` 값이 이전에 등장한 적이 있다면, 그 등장 횟수가 곧 현재 위치를 끝점으로 하는 합이 $K$인 구간의 개수입니다.
3. **초기값 설정 (`map.put(0L, 1L)`)**: 
   - 누적 합 자체가 $K$와 일치하는 경우(즉, 첫 원소부터 현재까지의 합이 $K$인 경우)는 `total - K = 0`이 됩니다. 이를 계산에 포함하기 위해 0의 개수를 미리 1로 설정합니다.
4. **자료형 오버플로우 주의**:
   - $N=200,000$일 때 가능한 모든 구간의 개수는 최대 약 **200억 개**입니다.
   - 이는 Java `int` 범위를 초과하므로 정답 변수 `ans`는 반드시 **`long`** 타입으로 선언해야 합니다.

---

### 💻 코드 주요 부분 설명
```java
// 1. 합이 K인 구간을 찾기 위한 초기값 (S[i] - 0 = K 인 경우 대비)
map.put(0L, 1L);

for (int i = 1; i <= N; i++) {
    // 2. 현재 위치까지의 누적 합 계산
    total += Long.parseLong(st.nextToken());

    // 3. S[j] = total - K 를 만족하는 이전 누적 합의 개수를 정답에 누적
    // map에서 (현재 누적합 - K)가 몇 번 나왔는지 찾아 ans에 더함
    ans += map.getOrDefault(total - K, 0L);

    // 4. 현재 누적 합을 Map에 기록 (다음 연산을 위해)
    map.put(total, map.getOrDefault(total, 0L) + 1);
}
```

⚠️ 핵심 포인트순서의 중요성: ans에 값을 먼저 더한 뒤 map.put을 수행해야 합니다. ($K=0$일 때 현재 자기 자신을 중복 카운트하는 것을 방지)시간 복잡도: $O(N)$으로, $N=200,000$인 조건에서도 약 200ms 내외로 안전하게 통과 가능합니다.

