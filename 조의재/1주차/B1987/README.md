# [Gold IV] 알파벳 - 1987 

[문제 링크](https://www.acmicpc.net/problem/1987) 

### 📊 성능 요약
- **메모리**: 304,916 KB
- **시간**: 1,620 ms
- **언어**: Java 11

### 📂 분류
- 그래프 이론
- 그래프 탐색
- 깊이 우선 탐색 (DFS)
- 백트래킹

---

### 📝 문제 설명
$R \times C$ 크기의 보드에서 각 칸에는 대문자 알파벳이 적혀 있습니다. 좌측 상단(0, 0)에서 시작하여 말이 이동하는데, **지금까지 지나온 모든 칸에 적혀 있는 알파벳과 중복되지 않는** 칸으로만 이동해야 합니다. 말이 이동할 수 있는 최대 칸 수를 구하는 것이 목표입니다.

---

### 🚀 핵심 로직 설명: 백트래킹 (Backtracking)

이 문제의 핵심은 DFS 탐색 과정에서 **조건에 맞지 않으면 즉시 되돌아오고, 다음 탐색을 위해 상태를 원복**하는 백트래킹 구조입니다.



```java
if (0 <= ddy && ddy < R && 0 <= ddx && ddx < C) { // 1. 경계 확인
    if (!visited[ddy][ddx] && !set.contains(arr[ddy][ddx])) { // 2. 방문 및 알파벳 중복 확인
        
        // [상태 변화] 현재 칸과 알파벳을 방문 처리
        set.add(arr[ddy][ddx]);
        visited[ddy][ddx] = true;

        // [재귀 호출] 다음 칸으로 이동하여 탐색 지속
        dfs(ddy, ddx, visited, set, count + 1);

        // [백트래킹] 다른 경로 탐색을 위해 현재 칸 기록 삭제 (원복)
        set.remove(arr[ddy][ddx]);
        visited[ddy][ddx] = false;
    }
}
```


🧐 성능 분석 및 개선 방향
현재 구현: HashSet을 사용하여 중복을 체크했습니다. 코드가 직관적이지만, 객체 생성 비용으로 인해 메모리와 시간 소모가 발생합니다.

최적화 아이디어:

Set 대신 boolean[26] 배열을 사용하여 알파벳 방문 여부를 체크하면 성능을 크게 높일 수 있습니다.

더 나아가 **비트마스킹(Bitmasking)**을 통해 정수형 변수 하나로 관리하면 메모리 효율이 극대화됩니다.
