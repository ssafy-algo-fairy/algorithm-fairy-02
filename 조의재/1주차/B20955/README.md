# [BOJ] 20955 - 민서의 응급수술

### 📌 문제 정보
* **문제 링크**: [백준 20955번](https://www.acmicpc.net/problem/20955)
* **난이도**: Gold 4
* **분류**: 자료 구조, 그래프 이론, 분리 집합 (Union-Find)

---

### 💡 풀이 전략
이 문제는 주어진 시냅스(간선)들을 최소한의 연산으로 조작하여 하나의 **트리(Tree)** 구조로 만드는 문제입니다.

1.  **트리의 특성 활용**: $N$개의 정점을 가진 트리는 항상 $N-1$개의 간선을 가지며, 모든 정점이 연결되어 있어야 하고 사이클이 없어야 합니다.
2.  **Union-Find 활용**:
    * 두 정점을 합칠 때(`union`), 이미 부모가 같다면 이는 **사이클**이 형성된 것이므로 해당 간선을 끊는 연산(`cycleCnt++`)이 필요합니다.
    * 모든 간선을 처리한 후, 서로 다른 집합(연결 요소)의 개수를 파악합니다.
3.  **최소 연산 계산**:
    * **끊기**: 사이클을 형성하는 모든 간선을 제거합니다.
    * **연결**: 서로 떨어진 $C$개의 뭉치(연결 요소)를 하나로 잇기 위해서는 $C-1$개의 간선이 추가로 필요합니다.

---

### 💡 핵심 풀이 로직



#### 1. 사이클 판별 및 제거 (Union-Find)
간선 정보를 입력받을 때마다 `union` 연산을 수행하여 이미 연결된 상태인지 확인합니다.
```java
if(!union(left, right)){
    cycleCnt++; // 이미 연결되어 있다면 사이클이므로 제거 연산 카운트
}
```

2. 연결 요소(Component) 개수 파악
모든 간선 처리가 끝난 후, parent[i] == i인 노드의 개수를 세어 현재 그래프가 몇 개의 덩어리로 나뉘어 있는지 확인합니다.

```
int needConnect = -1; // 덩어리가 C개면 필요한 간선은 C-1개이므로 -1부터 시작
for(int i=1; i<=N; i++){
    if(parent[i] == i) {
        needConnect++;
    }
}
```

✅ 복기 및 핵심 포인트
Union-Find의 효율성: 경로 압축(parent[x] = find(parent[x]))을 통해 $O(M \alpha(N))$의 빠른 속도로 사이클을 판별할 수 있었습니다.

트리의 조건: "모든 노드가 연결되어야 함"과 "사이클이 없어야 함"이라는 두 가지 조건을 각각 needConnect와 cycleCnt로 나누어 계산한 것이 주효했습니다.

초기값 설정: needConnect를 -1로 초기화하여 별도의 계산 없이 덩어리 개수 - 1을 바로 구할 수 있도록 처리한 디테일이 좋았습니다.
