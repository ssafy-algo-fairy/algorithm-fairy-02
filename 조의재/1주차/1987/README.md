# [Gold IV] 알파벳 - 1987 

[문제 링크](https://www.acmicpc.net/problem/1987) 

### 성능 요약
- **메모리**: (304916) KB
- **시간**: (1620) ms

### 분류
- 그래프 이론
- 그래프 탐색
- 깊이 우선 탐색 (DFS)
- 백트래킹

### 문제 설명
세로 $R$칸, 가로 $C$칸으로 된 표 모양의 보드가 있다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 상단 칸 ($1$행 $1$열)에는 말이 놓여 있다.

말은 상하좌우로 인접한 네 칸 중의 한 칸으로 이동할 수 있는데, 새로 이동한 칸에 적혀 있는 알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 한다. 즉, 같은 알파벳이 적힌 칸을 두 번 지날 수 없다.

좌측 상단에서 시작해서, 말이 최대한 몇 칸을 지날 수 있는지를 구하는 프로그램을 작성하시오. 말이 지나는 칸은 좌측 상단 칸도 포함된다.

### 풀이 전략

1. **DFS & 백트래킹**: 
   - 현재 위치에서 상하좌우를 탐색하며 다음 칸으로 이동합니다.
   - 이때, 이미 방문한 칸이거나(`visited`), 지금까지 지나온 경로에 이미 존재하는 알파벳(`Set.contains`)인 경우 이동하지 않습니다.
   
2. **상태 관리**:
   - `HashSet<Character>`를 사용하여 현재까지 경로에 포함된 알파벳을 효율적으로 관리했습니다.
   - 한 방향의 탐색이 끝나면 다른 경로를 탐색하기 위해 `set.remove()`와 `visited = false`를 통해 상태를 원복(Backtracking)합니다.

3. **최대값 갱신**:
   - 매 이동마다 `ans = Math.max(ans, count)`를 호출하여 말이 이동할 수 있는 최대 칸수를 갱신합니다.

### 코드 구현 포인트
- **좌표 이동**: `dx`, `dy` 배열을 사용하여 상하좌우 탐색을 간결하게 처리했습니다.
- **Set 활용**: 알파벳 중복 체크를 위해 `Set` 자료구조를 활용했습니다.
  - *Tip: 성능을 더 높이고 싶다면 `boolean[26]` 배열을 사용하여 알파벳 아스키 코드값으로 체크하는 방식도 좋습니다.*