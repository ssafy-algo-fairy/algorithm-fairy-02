# [BJ 16437] 양 구출 작전 - Java

### 📋 문제 개요
- **알고리즘 유형**: 트리 (Tree), 깊이 우선 탐색 (DFS), 포스트오더 (Post-order)
- **문제 핵심**: 각 섬에 위치한 양들이 1번 섬으로 이동하는 과정에서 늑대에게 잡아먹히지 않고 무사히 도달할 수 있는 최대 양의 마리 수를 구하는 문제입니다.

---

### 💡 풀이 로직
1. **데이터 구조**: 
   - `list[]`: 섬 사이의 연결 관계를 저장하는 인접 리스트 배열입니다. 트리의 부모-자식 관계를 표현합니다.
   - `sheepCnt[]`: 각 섬의 생명체 정보를 저장합니다. 양(`S`)은 **양수(+)**, 늑대(`W`)는 **음수(-)**로 처리하여 계산 효율을 높였습니다.
2. **후위 순회(Post-order) DFS**: 
   - 루트(1번 섬)에서 시작하여 리프 노드(말단 섬)까지 내려간 뒤, 다시 올라오면서 계산을 수행합니다.
   - 자식 노드에서 살아 돌아온 양의 합계를 먼저 구한 뒤, 현재 섬의 양/늑대 수와 연산합니다.
3. **생존 조건**: 
   - 현재 섬까지 도달한 양의 총합이 늑대의 수보다 적어 음수가 될 경우, `Math.max(0, sum)`을 통해 0마리가 생존한 것으로 처리합니다.
4. **자료형 선택**:
   - 최대 양의 수가 매우 클 수 있으므로(`10^9 * 123,456`), 정수 오버플로우를 방지하기 위해 `long` 타입을 사용합니다.

---

### 💻 코드 주요 부분 설명
```java
public static long dfs(int now) {
    long sum = 0;

    // 1. 하위 섬(자식 노드)들로부터 구출된 양의 마리수를 먼저 수집
    for(int next : list[now]){
        sum += dfs(next);
    }

    // 2. 현재 섬에 있는 양을 더하거나, 늑대에게 잡아먹힘
    sum += sheepCnt[now];

    // 3. 결과가 0보다 작으면 해당 경로에서 살아남은 양은 없음 (0 반환)
    return Math.max(0, sum);
}