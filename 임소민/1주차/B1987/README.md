# 🐎 알파벳 (BOJ 1987)

## 문제 요약

R×C 크기의 보드에서 좌측 상단(0, 0)에서 시작하여 상, 하, 좌, 우로 이동할 수 있다.  
이때 말이 이동한 칸에 적힌 알파벳은 **지금까지 지나온 모든 칸의 알파벳과 달라야 한다.**

좌측 상단을 포함하여, 말이 **최대로 이동할 수 있는 칸의 수**를 구하는 문제이다.

---

## ✔ 왜 DFS 인가?

현재 위치에서 상, 하, 좌, 우 네 방향으로 이동하면서  
**가능한 모든 경로를 끝까지 탐색해야 하기 때문에**  
각 경로를 깊게 따라가며 탐색하는 DFS가 적합하다.

---

## ✔ 왜 백트래킹이 필요한가?

한 경로에서 선택한 알파벳은  
다른 경로에서는 다시 사용할 수 있어야 한다.

따라서

- 어떤 알파벳을 선택하고
- 재귀 탐색을 진행한 뒤
- 다시 원래 상태로 되돌리는 과정이 반드시 필요하다.

이 과정을 위해 백트래킹을 사용한다.

---

## 🧩 상태 정의

현재 탐색 상태에서 필요한 정보는 다음과 같다.

| 항목         | 의미                        |
| ------------ | --------------------------- |
| (x, y)       | 현재 말의 위치              |
| alphabet[26] | 지금까지 사용한 알파벳 여부 |
| depth        | 현재까지 지나온 칸의 수     |

---

## 풀이 전략

1. (0, 0)에서 시작한다.
2. 현재 위치에서 4방향으로 이동을 시도한다.
3. 다음 칸의 알파벳이 아직 사용되지 않았다면 이동한다.
4. 이동 후 재귀 호출을 수행한다.
5. 재귀가 끝나면 알파벳 사용 상태를 되돌린다. (백트래킹)
6. 탐색 과정에서 이동한 칸 수의 최댓값을 갱신한다.

---

## 구현 포인트

- 이 문제에서 중요한 것은 같은 칸을 다시 방문하는지가 아니라  
  **같은 알파벳을 다시 사용하는지 여부**이다.
- 따라서 좌표 방문 배열(`visited[][]`) 없이  
  `alphabet[]` 배열만으로 탐색이 가능하다.

---

## 참고 – 처음 접근과 한계

처음에는 스택을 이용한 반복 DFS 방식으로 접근했지만,  
해당 방식은 한 번 사용한 알파벳을 되돌리지 않아  
다른 경로를 제대로 탐색하지 못하는 문제가 있었다.

이 문제는 경로마다 알파벳 사용 상태가 달라지므로,  
탐색이 끝난 뒤 상태를 복구하는 백트래킹이 반드시 필요하다.
