# 📦 백준 12865 - 평범한 배낭

## 문제 요약
각 물건은 무게 W, 가치 V를 가진다.  
배낭이 버틸 수 있는 최대 무게 K 안에서 물건을 일부 선택하여  
가치의 합을 최대로 만드는 문제이다.  
각 물건은 한 번만 선택할 수 있다.

---

## 접근 방법

DP 문제에 아직 익숙하지 않아,  
상태의 의미를 명확하게 보기 위해 일부러 2차원 DP로 풀이하였다.

---

## DP 정의

`dp[i][w]` 
→ i번째 물건까지 고려했을 때,  
   배낭 무게가 w인 경우의 최대 가치

---

## 풀이 전략 (핵심)

`dynamicProgramming()`메소드의 안쪽 `for문`에서는  
항상 다음 두 가지 선택을 고려한다.

### 1. i번째 물건을 담지 않는 경우

이전 단계(i-1)에서 이미 계산된 값과, 같은 단계(i)에서 다른 전이를 통해 갱신되어 있을 수도 있는 값을 비교해 최댓값으로 유지한다.
```java
dp[i][j] = Math.max(dp[i - 1][j], dp[i][j]);
```
### 2. i번째 물건을 담는 경우 - 기존 조합에 현재 물건 추가

이전에 만들 수 있었던 무게 j에서 현재 물건의 무게와 가치를 더해 새로운 상태를 만든다.   
코드에서는 visited 배열을 이용해 이전 단계에서 실제로 만들 수 있었던 무게만 대상으로 삼았다.

조건: `sum <= K`
```java
dp[i][sum] = dp[i - 1][j] + value;
visited[sum] = true;
```

### 3. i번째 물건을 담는 경우 - 현재 물건만 단독으로 담기

이전 조합이 없어도, 현재 물건 하나만 담는 경우를 따로 처리한다.
즉 무게가 정확히 weight일 때, 가치가 value가 될 수 있다.
```java
dp[i][weight] = Math.max(dp[i][weight], value);
visited[weight] = true;
```
---

## 정답

마지막 물건까지 고려한 뒤

`dp[N][0..K]` 중 최댓값을 출력한다.

(무게를 반드시 K까지 채울 필요는 없다)

---

## 정리

- DP 연습 단계이기 때문에 2차원 배열(dp[i][w])로 구현하였다.
- 배낭 문제의 핵심은
  “i번째 물건을 담는다 / 담지 않는다” 두 선택을 모두 고려하는 것이다.
- 안쪽 반복문에서 이 두 경우를 기준으로 DP를 갱신한다.
