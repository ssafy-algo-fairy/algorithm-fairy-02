# 수들의 합 4 (BOJ 2015) — 부분합 개수 세기

## 문제 요약

정수 배열 A[1..N]이 주어질 때, 모든 연속 부분구간 [i, j] (1 ≤ i ≤ j ≤ N)에 대해
부분합 A[i] + ... + A[j] 가 K가 되는 경우의 개수를 구한다.

* N ≤ 200,000
* |K| ≤ 2,000,000,000
* 각 원소의 절댓값 ≤ 10,000

---

## 핵심 아이디어

누적합(prefix sum)을 이용해 다음 관계를 활용한다.

* prefix[x] = A[1]부터 A[x]까지의 합
* 구간 [i, j]의 합 = prefix[j] - prefix[i-1]

구간 합이 K가 되려면

prefix[j] - prefix[i-1] = K
→ prefix[i-1] = prefix[j] - K

즉, 현재 위치 j에서
"이전에 prefix[j] - K 값이 몇 번 등장했는지"를 세면 된다.

---

## 풀이 전략

1. 왼쪽부터 배열을 한 번만 순회한다.
2. 현재까지의 누적합 prefix를 관리한다.
3. HashMap에 지금까지 등장한 누적합들의 개수를 저장한다.
4. 매 위치마다

   * map[prefix - K] 값을 정답에 더한다.
   * 이후 map[prefix]를 1 증가시킨다.

시작 전에 prefix = 0 이 한 번 등장한 것으로 처리해야
(맨 앞에서 시작하는 구간을 세기 위해) 한다.

---

## 왜 long을 써야 하는가?

### 1. 누적합(prefix) 오버플로 방지

원소 하나의 크기는 최대 10,000이고,
N이 200,000이므로 누적합은 최대 약 2,000,000,000까지 커질 수 있다.

또한 K가 ±2,000,000,000 범위이기 때문에

prefix - K 연산 결과는 int 범위를 넘어갈 수 있다.

따라서 누적합과 HashMap의 key는 반드시 long으로 관리해야 안전하다.

### 2. 정답 개수(answer) 오버플로 방지

최악의 경우 모든 부분구간이 조건을 만족하면

N × (N + 1) / 2

개의 구간이 생길 수 있다.

N = 200,000일 때 약 20,000,100,000 이므로
int 범위를 훨씬 초과한다.

→ answer는 반드시 long이어야 한다.

---

## 처음에 생각했던 방법과의 비교

### (1) 모든 부분합을 직접 계산하는 방식

모든 (i, j) 쌍에 대해

prefix[j] - prefix[i] 를 계산하는 방법

* 시간복잡도: O(N²)
* N = 200,000 이므로
  약 2 × 10¹⁰ 번 연산 → 시간 초과

따라서 현실적으로 불가능한 방법이다.

---

### (2) 최종 풀이 (누적합 + HashMap)

* 배열을 한 번만 순회

* 매 단계에서 HashMap 조회 및 갱신

* 시간복잡도: O(N)

* 공간복잡도: O(N)

N이 200,000이어도 충분히 통과 가능한 방식이다.

---

## 정리

이 문제의 핵심은

* 모든 구간을 직접 만들지 말고
* 현재 누적합 기준으로
* 과거 누적합의 개수를 이용해 구간 개수를 계산하는 것이다.

누적합 + HashMap을 이용하면
연속 부분합 문제를 O(N)에 해결할 수 있다.
