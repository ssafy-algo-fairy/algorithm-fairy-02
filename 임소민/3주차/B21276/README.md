# BOJ 21276 - 계보 복원가 호석

## 🧠 문제 핵심 요약

- 입력은 **직계 부모 정보가 아니라 조상 전체 정보**가 주어진다.
- 최종적으로 우리가 구해야 하는 것은  
  👉 **직계 부모-자식 관계만 남긴 트리 구조**
- 각 가문은 하나의 시조(root)를 가지는 트리 형태

---

## 💡 내가 문제를 접근한 생각 흐름

1. 현재 그래프에는  
   **직계 + 직계를 건너뛴 간선(조상 → 후손)** 이 모두 들어있다.

2. 우리가 해야 할 일은  
   👉 **직계를 건너뛴 간선을 제거하고 직계 관계만 남기는 것**

3. 그러려면  
   “조상들이 모두 제거된 순간이 언제인가?”를 알아야 한다.

4. 여기서 등장한 개념이 바로  
    🔥 **위상정렬(Kahn 알고리즘)**

   위상정렬 개념 이해에 도움 된 글  
   👉 https://bcp0109.tistory.com/21

---

## 🚀 공통 전략 (두 풀이 모두 동일)

### 1️⃣ 그래프 방향

입력: `X Y` → “X의 조상 중 Y가 있다”  
→ 간선: **Y → X (조상 → 자손)**

---

### 2️⃣ 위상정렬을 이용한 직계 판별

- indegree = 아직 남아있는 조상 수
- indegree가 0이 되는 순간  
  👉 그 부모가 해당 노드의 **직계 부모**

즉,

- indegree 감소 후 0이 되면 → 직계 자식
- 0이 아니면 → 직계를 건너뛴 간선 → 제거

이 방식으로
**조상 전체 그래프 → 직계 트리 구조**로 변환

---

# ✨ 풀이 1: String + TreeMap 기반

### 사용 자료구조

- `TreeMap<String, ArrayList<String>>`
- `TreeMap<String, Integer>`

### 특징

- 이름을 그대로 사용
- TreeMap이 자동으로 사전순 유지
- 구현이 직관적

### 단점

- TreeMap 접근은 `O(log N)`
- 문자열 비교 비용 존재
- 상수 시간이 큼

### 결과

- 메모리: 142064 KB
- 시간: 912 ms

---

# ⚡ 풀이 2: int 치환 + 배열 기반

### 사용 자료구조

- `String[] names` (사전순 정렬)
- `HashMap<String, Integer>` (이름 → 번호)
- `ArrayList<Integer>[]`
- `int[] indegree`

### 특징

- 이름을 숫자로 치환
- 그래프 탐색은 전부 배열 기반 → O(1)
- 사전순은 names 정렬 + 인덱스 순회로 해결

### 장점

- TreeMap 제거
- 문자열 비교 최소화
- 탐색 속도 빠름

### 결과

- 메모리: 134552 KB
- 시간: 648 ms

---

# 📊 두 풀이 차이 정리

| 항목        | String(TreeMap) | int(배열) |
| ----------- | --------------- | --------- |
| 구현 난이도 | 쉬움            | 매핑 필요 |
| 접근 속도   | log N           | O(1)      |
| 문자열 비교 | 많음            | 거의 없음 |
| 실행 시간   | 느림            | 빠름      |

---

## 🎯 결론

- 핵심 아이디어는 **위상정렬로 직계만 남기는 것**
- 성능 개선 포인트는  
  👉 **문자열 기반 자료구조 제거**
  👉 **배열 기반 그래프로 변환**

---

> 이 문제의 본질은 위상정렬을 이용해  
> “조상 정보”를 “직계 관계”로 정제하는 과정이다.
