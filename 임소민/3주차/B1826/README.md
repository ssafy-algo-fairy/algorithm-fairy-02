# 🚗 BOJ 1826 - 연료 채우기

## 📌 문제 요약

성경이는 트럭을 몰고 마을(L)까지 가야 한다.  
하지만 연료탱크에 구멍이 나서 **1km 이동할 때마다 1L의 연료가 소모된다.**

정글에는 N개의 주유소가 존재하며,
- 각 주유소는 시작점으로부터 거리 `a`
- 해당 주유소에서 얻을 수 있는 연료 `b`

트럭은 연료를 무제한으로 담을 수 있다.

👉 **목표:**  
마을까지 도달하기 위해  
**주유소에 멈추는 최소 횟수**를 구하라.

도달할 수 없다면 `-1` 출력.

---

## 🎯 핵심 관찰

- 연료는 많을수록 유리하다.
- "지금 당장 충전할지 말지"를 고민하는 문제가 아니다.
- **연료가 부족해지는 순간**, 지나온 주유소 중에서
  가장 많은 연료를 주는 곳을 선택하는 것이 최적이다.

즉,

> "도달 가능한 후보들 중 최댓값 선택"

---

## 🧠 풀이 전략 (Greedy + PriorityQueue)

### 1️⃣ 주유소를 거리 기준 오름차순 정렬

현재 연료로 도달 가능한 주유소만 고려해야 하므로,
거리 기준으로 정렬이 필요하다.

→ `PriorityQueue<int[]>` 사용

---

### 2️⃣ 현재 연료로 갈 수 있는 주유소들을 모은다

```java
while (stations.peek()[0] <= curDist)
    fuel.add(station의 연료)
```
👉 현재 도달 가능한 주유소들의 연료를 따로 모은다.

---

### 3️⃣ 더 이상 전진 불가능한 순간

- `fuel PQ`에서 가장 큰 연료를 꺼내 충전

- 충전 횟수 증가
```java
curDist += fuel.poll();
answer++;
```

---

### 4️⃣ fuel이 비어 있다면?

더 이상 선택 가능한 주유소가 없다는 뜻

→ 도달 불가 → `-1`

---

### 🔥 왜 이게 그리디로 맞는가?
### ✔ 교환 논증 직관

- 작은 연료를 먼저 넣고 나중에 큰 연료를 넣는 것보다

- 큰 연료를 먼저 넣는 것이 항상 유리하다.

연료는 많을수록 선택지가 넓어지므로,
최댓값 선택이 항상 최적이다.

### ⏱ 시간 복잡도

- 주유소 삽입: `O(N log N)`

- 각 주유소는 최대 한 번만 poll됨

- 전체 시간복잡도: `O(N log N)`

N ≤ 10,000 → 충분히 통과

---

### 📌 자료구조 정리
| 역할 | 자료구조 |
|------|----------|
| 거리 기준 정렬 | PriorityQueue<int[]> |
| 최대 연료 선택 | PriorityQueue<Integer> |

---

### 💡 이 문제의 핵심 한 줄 정리

> "충전은 필요할 때만 하고,     
> 그때는 지나온 주유소 중 가장 많은 연료를 선택한다."

### 🏷 알고리즘 분류

- 그리디 (Greedy)

- 우선순위 큐 (Priority Queue)

- 정렬
