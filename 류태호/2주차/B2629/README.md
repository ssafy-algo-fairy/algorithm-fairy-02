### 📌 문제 정보

- 번호: 2629
- 제목: 양팔저울
- 난이도: Gold 3
- 분류: 다이나믹 프로그래밍, 배낭 문제

---

### 💡 접근 방식

> 추들을 이용해 만들 수 있는 모든 차이를 구한 뒤, 구슬의 무게가 해당 차이와 같은지 확인하여 해결했습니다.

#### 1단계 - 상태 정의
dp[d]를 사용하여 무게 차이가 d가 될 수 있는지 여부를 저장했습니다.

#### 2단계 - 추를 하나씩 반영
각 추에 대해, 기존에 가능했던 모든 차이 d를 기준으로 새로운 차이를 확장했습니다.  
가능한 전이는 다음과 같습니다.

- 추를 사용하지 않음 → d
- 반대편에 올림 → d + w
- 같은 편에 올림 → |d - w|

같은 추를 여러 번 사용하는 것을 방지하기 위해 temp 배열을 사용해 한 단계씩 갱신했습니다.

#### 3단계 - 구슬 판별
모든 구슬 무게 x에 대해 dp[x] == true이면 Y, 아니면 N을 출력했습니다.

---

### 💻 핵심 코드 (DP 부분)

```java
static boolean[] dp = new boolean[40001];

dp[0] = true;

for (int w : weight) {
boolean[] temp = new boolean[40001];

    for (int d = 0; d <= 40000; d++) {
        if (!dp[d]) continue;

        if (d + w <= 40000) temp[d + w] = true;

        int nd = Math.abs(d - w);
        temp[nd] = true;
    }

    for (int d = 0; d <= 40000; d++) {
        if (temp[d]) dp[d] = true;
    }
}
```
---

### ⏳ 복잡도 계산

시간 복잡도: O(N × 40000)
- N ≤ 30
- 최대 약 1,200,000번 연산으로 충분히 통과

공간 복잡도: O(40000)
- dp 배열 하나로 관리

---

### ⚠️ 고민 지점

- 처음에는 일반적인 DP로 생각해서 구슬의 무게를 직접 만들 수 있는지 여부를 기준으로 하려고 했습니다.
- 하지만 저울에서 양쪽 무게의 차이를 기준으로 해야하는 것으르 알고 상태를 `구슬 무게`가 아니라 `무게 차이`로 정의해야 하는 것을 알았습니다.
- 그 과정에서 knapsack의 응용이라는 것을 알게 되었고, 합이 아닌 차이를 기준으로 해결했습니다.
---

### 🆕 새롭게 알게 된 것

- 이 문제는 일반 0/1 배낭 문제의 변형으로 볼 수 있다는 점
- 상태를 합이 아니라 차이로 정의할 수 있다는 점

---

### 📚 핵심 개념 정리

- dp[d]는 만들 수 있는 무게 차이 집합을 의미한다.
- 추 하나가 추가될 때마다 기존 상태에서 `d + w`과 `|d - w|` 를 확장한다.
- 최종적으로 구슬 무게가 가능한지 여부를 확인한다

---

### 📌 언제 이런 방식이 사용되는가

- 0/1 선택 구조에서 가능한 상태 집합을 계산해야 할 때
- 합 또는 차이 기반의 Subset 문제
- 양방향(더하기/빼기) 상태 전이가 존재하는 문제  