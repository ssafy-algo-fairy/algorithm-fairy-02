### 📌 문제 정보

- **번호:** 17472
- **제목:** 다리 만들기 2
- **난이도:** Gold 3
- **분류:** 그래프, 최소 신장 트리(MST), 분리 집합(Union-Find), BFS

---

### 💡 접근 방식

> 섬을 정점으로 보고, 섬 사이를 연결할 수 있는 최소 다리 길이를 간선으로 구성한 뒤 최소 신장 트리를 구하는 방식으로 해결했습니다.

#### 1단계 - 섬 라벨링
- BFS를 사용해 연결된 땅을 하나의 섬으로 묶고 번호를 부여했습니다.

#### 2단계 - 다리 후보 탐색
- 각 섬에서 최소 길이의 다리를 구했습니다.
- dist[i][j]에 섬 i와 j 사이의 최소 다리 길이를 저장했습니다.

#### 3단계 - MST 구성 (혼자 못 함)
- dist 배열을 기반으로 간선 리스트를 생성하고, 크루스칼 알고리즘을 이용해 최소 연결 비용을 계산했습니다.

---

### 💻 핵심 코드 (MST 부분)

```java
static int kruskal(int landNum) {  
List<Edge> edges = new ArrayList<>();

    for (int i = 1; i <= landNum; i++) {  
        for (int j = i + 1; j <= landNum; j++) {  
            if (dist[i][j] != Integer.MAX_VALUE) {  
                edges.add(new Edge(i, j, dist[i][j]));  
            }  
        }  
    }  

    Collections.sort(edges);  

    parent = new int[landNum + 1];  
    for (int i = 1; i <= landNum; i++) parent[i] = i;  

    int total = 0;  
    int used = 0;  

    for (Edge e : edges) {  
        if (union(e.from, e.to)) {  
            total += e.weight;  
            used++;  
        }  
    }  

    return (used == landNum - 1) ? total : -1;  
}
```

---

### ⏳ 복잡도 계산

- **시간 복잡도:** O(NM + E log E)
    - 섬 라벨링: O(NM)
    - 다리 탐색: O(NM)
    - 간선 정렬: O(E log E)

- **공간 복잡도:** O(NM + E)
    - 지도, 방문 배열: O(NM)
    - dist 배열 및 간선 리스트: O(E)

---

### ⚠️ 고민 지점

- 섬 사이의 최소 다리 길이까지는 구했지만, 그 이후 어떻게 최소 비용으로 전체를 연결해야 하는지 바로 떠오르지 않았습니다.
- 단순히 최소 길이를 더하는 방식으로는 해결되지 않아서, 최소 신장 트리 개념을 찾아보게 되었습니다.
- 그 과정에서 크루스칼 알고리즘을 알고, 이를 통해 해결했습니다.

---

### 🆕 새롭게 알게 된 것

- 모든 정점을 최소 비용으로 연결하는 문제는 MST로 모델링할 수 있다는 점
- 크루스칼 알고리즘과 유니온 파인드의 연계 사용법
---

### 📚 크루스칼 알고리즘 정리

- 가중치가 있는 그래프에서 최소 신장 트리를 구하는 그리디 알고리즘
- 간선을 가중치 기준으로 오름차순 정렬
- 작은 간선부터 선택하며 사이클이 생기면 제외
- 정점 개수 - 1개의 간선이 선택되면 종료

---

### 📌 언제 사용하는가

- 모든 정점을 연결해야 할 때
- 간선 가중치의 합을 최소화해야 할 때
- 사이클 없이 최소 비용 네트워크를 구성해야 할 때  