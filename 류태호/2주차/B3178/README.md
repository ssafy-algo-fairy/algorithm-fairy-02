### 📌 문제 정보

- **번호:** 3178  
- **제목:** 코코스  
- **난이도:** Gold 3
- **분류:** 문자열, 정렬, 트리/트라이, 구현  

---

### 💡 접근 방식
> - 앞쪽 K글자들은 “공통 접두사”를 최대한 공유하도록  
> - 뒤쪽 K글자들은 “공통 접미사”를 최대한 공유하도록  
> 만들어야 합니다.  
>  
> 이를 위해 각 단어를 앞뒤로 나누고,  
> 뒤쪽 글자는 뒤에서부터 확인하기 위해 뒤집어서 처리한 후
> 각각 정렬하여 인접한 문자열끼리 비교했습니다.

---

### 🔹 1단계 – 앞/뒤 분리

- 각 단어에서 앞 뒤 분할
  - `prefix = word[0..K-1]`
  - `suffix = word[K..2K-1]`  
- suffix는 앞을 비교하는 것 처럼 뒤에서부터 비교하기 위해 뒤집어서 저장

---

### 🔹 2단계 – 정렬 후 인접 원소 비교

- 배열을 사전순 정렬하면 공통 겹치는 부분이 긴 문자열들이 정렬됨
- 인접한 두 문자열의 공통 접두사 길이를 `count()`로 구하고,
  `K - 겹치는 부분`만큼이 추가로 생성해야하는 노드 수

---

### 🔹 3단계 – 정답 계산

- 첫 문자열의 앞 뒤는 각각 길이 K만큼 무조건 필요하므로 초기값은 `2K`
- 이후 정렬된 배열에서 인접한 원소마다 `K - 겹치는 부분`을 누적하여 최소 정점 수를 구함

---

### 💻 핵심 로직

```java
// 첫 글자는 어차피 무조건 써야함
int ans = K * 2;

for (int i = 1; i < N; i++) {
    ans += (K - count(prefix[i - 1], prefix[i]));
    ans += (K - count(suffix[i - 1], suffix[i]));
}
```

```java
// 겹치는 부분 계산
static int count(String s1, String s2) {
    int count = 0;
    for (int i = 0; i < s1.length(); i++) {
        if (s1.charAt(i) == s2.charAt(i)) count++;
        else break;
    }
    return count;
}
```

---

### ⏳ 복잡도 분석

- **시간 복잡도:**  
  O(N log N × K)
    - 정렬: O(N log N)
    - 인접 비교: O(N × K)

- **공간 복잡도:**  
  O(N × K)
    - prefix/suffix 저장

---

### ⚠️ 어려웠던 점

- 처음에는 문제 설명 그대로 **그래프를 직접 구성해서 최소 정점 수를 구하려고** 했는데, 
- 구현하는 과정이 복잡해서 방향을 잡기 어려웠습니다.
- 이후 레퍼런스를 찾아보면서 반으로 나눠서 뒷부분을 앞부분처럼 처리하는 법을 알고 해결했습니다.