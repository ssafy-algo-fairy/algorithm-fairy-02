### 📌 문제 정보

- **번호:** 18808  
- **제목:** 스티커 붙이기  
- **난이도:** Gold 3  
- **분류:** 구현, 시뮬레이션  

---

### 💡 접근 방식

> 주어진 스티커들을 순서대로 노트북에 붙이며, 최대한 많은 칸을 채우는 문제로 완전 탐색 기반 시뮬레이션으로 해결했습니다.

#### 1단계 - 스티커 순회
- 각 스티커를 순서대로 처리했습니다.
- 스티커는 최대 4번까지 회전하며 시도합니다.

#### 2단계 - 위치 탐색
- 현재 방향 그대로 노트북의 `(0,0)`부터 `(N-R, M-C)`까지 모든 위치를 확인합니다.
- 해당 위치에 겹치지 않고 붙일 수 있는지 `canAttach()`로 검사합니다.
- 붙일 수 있으면 `attach()`로 노트북에 반영하고 다음 스티커로 넘어갑니다.

#### 3단계 - 회전
- 현재 방향으로 붙일 수 없다면 90도 시계 방향으로 회전합니다.
- 회전 공식:
  - `(r, c) → (c, R - 1 - r)`

#### 4단계 - 최종 계산
- 모든 스티커 처리가 끝난 뒤 노트북에서 값이 1인 칸의 개수를 세어 출력합니다.

---

### 💻 핵심 코드 (회전 부분)

```java
static int[][] rotate(int[][] sticker) {
    int R = sticker.length;
    int C = sticker[0].length;
    int[][] next = new int[C][R];

    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++) {
            next[j][R - 1 - i] = sticker[i][j];
        }
    }

    return next;
}
```

---

### ⏳ 복잡도 계산

- **시간 복잡도:**  
  스티커 개수 K × 4(회전) × N × M × 스티커 크기  
  (최대 입력에서도 충분히 통과 가능)

- **공간 복잡도:**  
  O(N × M + 스티커 전체 크기)

---

### ⚠️ 느낀 점

- 구현 난이도는 크게 어렵지 않았지만, 배열을 90도 회전하는 방법이 생각이 안 나서 조금 헤맸습니다. 
- 좌표 변환 `(r, c) → (c, R - 1 - r)` 방법을 기억해두면 좋을 것 같습니다.

---

### 📌 핵심 정리
- 완전 탐색 기반 시뮬레이션 문제
- 붙일 수 있으면 즉시 붙이고 다음 스티커로 이동
- 회전은 좌표 변환 공식을 이용해 구현