### 📌 문제 정보

- **번호:** 19591  
- **제목:** 독특한 계산기  
- **난이도:** Gold 3
- **분류:** 구현, 문자열, 파싱, 덱(Deque), 자료구조  

---

### 💡 접근 방식

> 수식에서 매 단계마다 **맨 앞 연산자 또는 맨 뒤 연산자** 중 하나를 선택해 계산하며,  
> 우선순위(`*`,`/` > `+`,`-`)와 결과값 비교 규칙에 따라 어떤 쪽을 먼저 계산할지 결정합니다.  
> 이를 위해 수식을 숫자/연산자로 분해해 **Deque**에 저장하고, 양 끝에서 연산 후보를 꺼내며 시뮬레이션했습니다.

---

### 🔹 1단계 – 수식 파싱 (Deque 구성)

- 수식을 왼쪽부터 읽으며 숫자를 누적하다가 연산자를 만나면 누적된 숫자를 저장하고 연산자도 저장
- 식이 `-`로 시작하는 경우는 미리 숫자를 저장
---

### 🔹 2단계 – 양 끝 연산 비교

- 앞 : `a op1 b`
- 뒤 : `c op2 d`

1) 우선순위 비교 (`*`,`/` 우선)  
2) 우선순위가 같으면 계산 결과가 큰 쪽  
3) 결과도 같으면 앞쪽 우선  

선택된 쪽을 계산한 뒤 덱을 갱신하며 반복

---

### 🔹 3단계 – 덱 크기에 따른 처리

- 덱 크기 1: 숫자만 남음 → 출력
- 덱 크기 3: `a op b` 한 번 계산 후 출력
- 덱 크기 5: 가운데 숫자가 양쪽 연산에 동시에 사용될 수 있어 예외 처리 필요
- 덱 크기 7 이상: 앞/뒤 후보를 각각 계산해 비교 후 선택

---

### 💻 핵심 로직

#### 연산자 우선순위 비교

```java
static int higher(String op1, String op2) {
    int p1 = (op1.equals("*") || op1.equals("/")) ? 1 : 0;
    int p2 = (op2.equals("*") || op2.equals("/")) ? 1 : 0;
    if (p1 > p2) return 1; // 앞 우선
    if (p2 > p1) return 2; // 뒤 우선
    return 0;              // 동급
}
```

#### 연산 수행

```java
static long calculate(long a, long b, String op) {
    if (op.equals("+")) return a + b;
    if (op.equals("-")) return a - b;
    if (op.equals("*")) return a * b;
    return a / b;
}
```

---

### ⏳ 복잡도 분석

- **시간 복잡도:** O(L)
    - L은 수식 길이
    - 덱에서 연산을 한 번 수행할 때마다 원소 수가 줄어들어 전체적으로 선형 수행

- **공간 복잡도:** O(L)
    - 덱에 토큰(숫자/연산자)을 저장
---

### ⚠️ 어려웠던 점

- 덱의 원소가 5개인 경우에는 가운데 숫자가 양쪽 연산에 동시에 포함될 수 있어,
  앞을 계산할지 뒤를 계산할지 비교하는 과정에서 덱을 어떻게 복구/갱신할지 찾는 데 시간이 걸렸습니다.