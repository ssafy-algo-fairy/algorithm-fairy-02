### 📌 문제 정보

- **번호:** 1103  
- **제목:** 게임  
- **난이도:** Gold 2  
- **분류:** DFS, 그래프 탐색, 다이나믹 프로그래밍(DP), 사이클 판별

---

### 💡 접근 방식

> 동전이 이동할 수 있는 최대 횟수를 구하는 문제로, DFS 기반 탐색에 DP(메모이제이션)를 결합하여 해결했습니다.  
> 또한, 무한히 움직일 수 있는 경우를 판별하기 위해 사이클 감지를 함께 구현했습니다.

---

### 🔹 문제 핵심

- 현재 위치의 숫자 X만큼 상하좌우 중 한 방향으로 이동
- 구멍이나 보드 밖으로 나가면 종료
- 같은 경로를 반복할 수 있다면 → 무한 반복 → `-1` 출력

---

### 🔹 1단계 – DFS 탐색

- `(r, c)` 위치에서 4방향으로 이동
- `map[r][c]` 값을 이용해 점프
- 이동 가능한 위치에 대해 재귀 호출

---

### 🔹 2단계 – 사이클 판별

- DFS 중 현재 경로에서 다시 방문한 칸이 나오면 사이클
- 이를 위해 `visited[r][c]` 사용
- DFS 중 `visited[r][c] == true`이면 즉시 `-1` 반환

```java
if (visited[r][c]) {
    return -1;
}
```

---

### 🔹 3단계 – DP(메모이제이션) 적용

- 이미 계산한 위치의 최대 이동 횟수를 저장
- `dp[r][c] != 0`이면 저장된 값 반환
- 이를 통해 중복 탐색 방지

```java
if (dp[r][c] != 0) {
    return dp[r][c];
}
```

---

### 🔹 4단계 – 결과 계산

- 각 방향에서 얻은 결과 중 최대값 선택
- 현재 칸을 포함하므로 `max + 1`

```java
dp[r][c] = max + 1;
return max + 1;
```

---

### 💻 핵심 로직

```java
static int dfs(int r, int c) {
    if (visited[r][c]) return -1;
    if (dp[r][c] != 0) return dp[r][c];

    visited[r][c] = true;
    int max = 0;

    for (int i = 0; i < 4; i++) {
        int nr = r + dr[i] * map[r][c];
        int nc = c + dc[i] * map[r][c];

        if (nr >= 0 && nr < N && nc >= 0 && nc < M && map[nr][nc] != 0) {
            int res = dfs(nr, nc);
            if (res == -1) return -1;
            max = Math.max(max, res);
        }
    }

    visited[r][c] = false;
    dp[r][c] = max + 1;
    return max + 1;
}
```

---

### ⏳ 복잡도 분석

- **시간 복잡도:** O(N × M)  
  (각 칸을 한 번씩만 계산, DP 적용)

- **공간 복잡도:** O(N × M)  
  (`dp`, `visited`, `map` 배열)

---

### ⚠️ 어려웠던 점
- 처음에는 단순 DFS로 모든 경로를 탐색했으나, 시간 초과가 발생했습니다.
- 선규님의 입력 예시를 보고, DP(메모이제이션)를 적용하여 이미 계산한 위치를 재사용하도록 수정했습니다.
