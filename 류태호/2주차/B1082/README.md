### 📌 문제 정보

- **번호:** 1082
- **제목:** 방 번호
- **난이도:** Gold 3
- **분류:** 그리디

---

### 💡 접근 방식

> 예산 M으로 숫자를 구매해 만들 수 있는 가장 큰 수를 구하는 문제로, 자릿수를 최대화한 뒤 왼쪽부터 값을 키우는 그리디로 해결했습니다.

#### 1단계 - 최저가 숫자 찾기
- `minFirst`: 1~N-1 중 가장 싼 숫자 (첫 자리는 0 불가)
- `min`: 0~N-1 중 가장 싼 숫자 (자리 채우기용)

#### 2단계 - 자릿수(자릿수) 최대화
- 첫 자리에 `minFirst`를 1개 구매
- 남은 돈으로 `min`을 최대한 많이 구매해 뒤에 채움
- 이 과정으로 만들 수 있는 수의 자릿수가 최대가 됨 (자릿수가 길면 무조건 더 큼)

#### 3단계 - 왼쪽부터 업그레이드
- 남은 돈으로 각 자리 숫자를 더 큰 숫자로 바꿀 수 있으면 교체
- 왼쪽 자리가 커질수록 더 커지므로 왼쪽부터 교체
- 차액을 계산하며 교체

---

### 💻 핵심 코드 (업그레이드 부분)
```java
char[] digits = sb.toString().toCharArray();

for (int i = 0; i < digits.length; i++) {
    int cur = digits[i] - '0';

    for (int d = N - 1; d >= 0; d--) {
        if (i == 0 && d == 0) continue;

        int diff = p[d] - p[cur];
        if (diff <= money) {
            digits[i] = (char) ('0' + d);
            money -= diff;
            break;
        }
    }
}
```
---

### ⏳ 복잡도 계산

- **시간 복잡도:** O(L × N)
  - L = 최종 자릿수 자릿수
  - 각 자리에서 N-1부터 0까지 업그레이드 가능 여부 확인

- **공간 복잡도:** O(L)
  - 결과 자릿수 저장용 배열/문자열

---

### ⚠️ 고민 지점

- 처음에는 금액순으로 정렬해서 가장 싼 숫자로 길게 채우려고 했습니다.
- 하지만 이렇게만 하면 자릿수는 맞아도 가장 큰 수라는 보장이 없었습니다. 
- 그래서 자릿수를 먼저 구한 후, 남은 돈으로 왼쪽 자리부터 크게 만들며 해결했습니다.

---

### 🆕 새롭게 알게 된 것

- 큰 수 비교에서 **자릿수가 최우선**이라는 점
- 그 다음은 **왼쪽 자리부터** 키우는 것이 최적이라는 점
- 자릿수 최대화 → 자리 업그레이드 형태의 그리디 패턴

---

### 📌 언제 사용하는가

- 결과가 문자열로 만든 수이고, 자릿수가 우선순위인 최대화 문제
- 예산으로 구성 요소를 구매해 최적의 문자열/숫자를 만드는 문제
- 먼저 전체 구조(자릿수/개수)를 고정한 뒤, 부분을 개선하는 그리디가 성립하는 문제