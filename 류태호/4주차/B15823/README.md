### 📌 문제 정보

- **번호:** 15823  
- **제목:** 카드 팩 구매하기  
- **난이도:** Gold 2  
- **분류:** 이분 탐색, 슬라이딩 윈도우, 해시/배열(중복 체크)

---

### 💡 접근 방식

> 카드팩의 길이 `L`을 정하고, 길이 `L`인 연속 구간 중에서 **중복 없는 구간을 겹치지 않게 M개** 만들 수 있는지 검사했습니다.  
> `L`이 커질수록 조건을 만족하기 어려워지기 때문에, 이분 탐색으로 가능한 최대 `L`을 찾았습니다.

---

### 🔹 1단계 – 이분 탐색으로 팩 길이 L 결정

- 한 팩의 길이를 `L`이라 하면, M개 팩을 만들려면 만들 수 있는 최대 길이는 `N / M`
- `canBuy(L)`이 true면 더 큰 길이도 가능한지 확인, false면 줄이는 방식으로 최대값 탐색

---

### 🔹 2단계 – canBuy(L): 슬라이딩 윈도우로 M개 가능한지 확인

- `start ~ i`를 현재 윈도우로 잡고, 중복이 없는 상태를 유지
- `last[x]`에 카드 번호 `x`의 마지막 등장 위치를 저장해 중복 발생 시 `start`를 점프
- 윈도우 길이가 `L`이 되면 팩 1개 확정하고, **겹치면 안 되므로** `start = i + 1`로 다음 팩을 새로 시작

---

### 💻 핵심 로직

#### 이분 탐색

```java
int answer = 0;
int max = N / M;
while (answer < max) {
    int mid = (answer + max + 1) / 2;
    if (canBuy(mid)) answer = mid;
    else max = mid - 1;
}
```

#### 슬라이딩 윈도우 검사

```java
if (last[card] >= start) {
    start = last[card] + 1;
}
last[card] = i;

if (i - start + 1 == buyCnt) {
    cnt++;
    if (cnt >= M) return true;
    start = i + 1;
}
```

---

### ⏳ 복잡도 분석

- **시간 복잡도:** O(N log(N/M))
    - `canBuy(L)`는 한 번에 O(N)
    - 이분 탐색은 최대 log(N/M)번 수행

- **공간 복잡도:** O(V)
    - `last` 배열(카드 번호 범위 크기만큼)

---

### ⚠️ 어려웠던 점

- 처음에는 가능한 N을 전부 다 시도해보려고 했는데, 시간 초과가 날 것 같았고, 고민하다 이분탐색을 적용했습니다.
- 중복 없는 구간을 효율적으로 찾기 위해 슬라이딩 윈도우를 써야 한다는 점도 처음에는 잘 떠오르지 않았습니다.
