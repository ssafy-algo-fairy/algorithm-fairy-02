# 🍣 백준 15961번 - 회전 초밥

## 📌 문제 요약

회전 초밥 벨트 위에 접시가 원형으로 놓여 있다. 연속해서 **k개**의 접시를 선택해 먹을 수 있고, 추가로 **쿠폰 번호 c**에 해당하는 초밥을 무료로 하나 더 먹을 수 있다.

목표는 **연속된 k개의 접시 + 쿠폰 초밥**을 고려했을 때, **서로 다른 초밥 종류의 최대 개수**를 구하는 것이다.

---

## 🧠 이 코드의 핵심 전략

이 풀이는 **슬라이딩 윈도우 + 큐(Queue)** 를 이용해 원형 회전 초밥을 직접 시뮬레이션한다.

특징은 다음과 같다.

* 쿠폰 초밥 `c`를 **미리 방문 처리**해서 항상 포함되도록 구성
* 실제 윈도우는 큐(`Queue`)로 관리
* 마지막 접시 이후의 원형 처리는 **처음 k개의 초밥을 따로 저장(tmp 큐)** 해서 해결

---

## ⚙️ 변수 설명

```java
int[] visited = new int[d + 1]; // 초밥 종류별 등장 횟수
visited[c] = 1;               // 쿠폰 초밥은 항상 포함

int count = 1; // 현재 서로 다른 초밥 종류 수 (쿠폰 포함)
int max = 1;   // 최대 종류 수

Queue<Integer> q   = new LinkedList<>(); // 현재 슬라이딩 윈도우
Queue<Integer> tmp = new LinkedList<>(); // 원형 처리를 위한 처음 k개 저장
```

---

## 🔄 알고리즘 흐름

### 1️⃣ 입력 처리 + 초기 윈도우 구성

```java
for (int i = 1; i <= n; i++) {
    int in = Integer.parseInt(br.readLine());

    if (i <= k) tmp.add(in); // 원형 처리용

    if (i > k) {
        int out = q.poll();
        if (out != c) {
            visited[out]--;
            if (visited[out] == 0) count--;
        }
    }

    q.add(in);
    if (in != c) {
        visited[in]++;
        if (visited[in] == 1) {
            count++;
            max = Math.max(max, count);
        }
    }
}
```

* 처음 `k`개는 원형 연결을 위해 `tmp` 큐에 저장
* `k`개를 초과하면 윈도우에서 하나 제거
* 새로운 초밥을 추가하면서 **종류 수 갱신**

---

### 2️⃣ 원형 구간 처리 (마지막 → 처음)

```java
for (int i = 0; i < k; i++) {
    int in = tmp.poll();

    int out = q.poll();
    if (out != c) {
        visited[out]--;
        if (visited[out] == 0) count--;
    }

    q.add(in);
    if (in != c) {
        visited[in]++;
        if (visited[in] == 1) {
            count++;
            max = Math.max(max, count);
        }
    }
}
```

* 마지막 접시 이후, 처음 접시들과 이어지는 경우를 직접 시뮬레이션
* `tmp` 큐에 저장해 둔 처음 `k`개의 초밥을 다시 투입

---

## 🎯 쿠폰 처리 방식의 포인트

* 쿠폰 초밥 `c`는 처음부터 `visited[c] = 1`, `count = 1`로 시작
* 윈도우에 들어오거나 나갈 때 **쿠폰 초밥은 무시**

```java
if (in != c) { ... }
if (out != c) { ... }
```

➡️ 덕분에 매번 `+1` 여부를 체크할 필요 없이
항상 쿠폰이 포함된 상태로 최대값을 계산할 수 있다.

---

## ⏱️ 시간 복잡도

* **O(N)**
* 각 초밥은 최대 한 번 들어오고 한 번 나간다

## 💾 공간 복잡도

* **O(d + k)**
* 방문 배열 + 큐 사용

---

## ✅ 정리

* 원형 배열을 **큐와 보조 큐(tmp)** 로 깔끔하게 처리한 풀이
* 쿠폰을 미리 포함시키는 방식 덕분에 조건 분기가 단순해짐
* 직관적인 시뮬레이션 기반 슬라이딩 윈도우 구현