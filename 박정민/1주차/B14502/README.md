# 🧪 백준 14502번 연구소

## 📌 문제 요약

연구소는 `N x M` 크기의 격자로 이루어져 있으며,

* `0` : 빈 칸
* `1` : 벽
* `2` : 바이러스

가 주어진다. 빈 칸 중 **3곳에 벽을 새로 세운 뒤**, 바이러스가 상하좌우로 퍼졌을 때 **안전 영역(0의 개수)의 최댓값**을 구하는 문제이다.

---

## 💡 풀이 아이디어

이 문제는 크게 두 단계로 나누어 해결한다.

1. **벽 3개를 세우는 모든 경우 탐색**
2. **각 경우마다 바이러스 확산을 시뮬레이션**

격자의 크기가 최대 `8 x 8`로 작기 때문에, **완전 탐색 + DFS** 전략이 충분히 가능하다.

---

## 🧠 접근 방법

### 1️⃣ 벽 세우기 (DFS + 백트래킹)

* 빈 칸(`0`)을 하나씩 벽(`1`)으로 바꾸며 DFS 수행
* 벽을 3개 세우면 더 이상 탐색하지 않고 시뮬레이션 단계로 이동
* DFS 종료 후에는 다시 원상 복구하여 다음 경우를 탐색 (백트래킹)

```java
public static void dfs(int depth) {
    if (depth == 3) {
        // 시뮬레이션 수행
        return;
    }
    
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (map[i][j] == 0) {
                map[i][j] = 1;
                dfs(depth + 1);
                map[i][j] = 0; // 백트래킹
            }
        }
    }
}
```

---

### 2️⃣ 맵 복사

* 벽 배치마다 **기존 맵을 훼손하지 않기 위해** 깊은 복사 수행

```java
int[][] copyMap = new int[n][];
for (int i = 0; i < n; i++) {
    copyMap[i] = map[i].clone();
}
```

---

### 3️⃣ 바이러스 확산 (DFS)

* 초기 바이러스 위치를 미리 저장해두고
* 각 바이러스 위치에서 DFS로 상하좌우 전파
* 빈 칸(`0`)을 만나면 바이러스(`2`)로 변경하며 재귀 호출

```java
public static void spread(int[][] map, int x, int y) {
    int[] dx = {1, -1, 0, 0};
    int[] dy = {0, 0, 1, -1};

    for (int d = 0; d < 4; d++) {
        int nx = x + dx[d];
        int ny = y + dy[d];
        if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
            if (map[nx][ny] == 0) {
                map[nx][ny] = 2;
                spread(map, nx, ny);
            }
        }
    }
}
```

---

### 4️⃣ 안전 영역 계산

* 바이러스 확산이 끝난 후
* 맵 전체를 순회하며 `0`의 개수를 카운트
* 최댓값 갱신

---

## ⏱️ 시간 복잡도

* 벽을 세우는 경우의 수: 최대 `C(64, 3)`
* 각 경우마다 바이러스 확산: `O(N × M)`

➡️ 전체적으로 제한 시간 내 충분히 통과 가능

---

## ✅ 핵심 포인트 정리

* **DFS + 백트래킹**으로 벽 3개 조합 탐색
* **맵 깊은 복사**로 원본 보존
* **재귀 DFS**를 이용한 바이러스 확산
* 안전 영역의 **최댓값 갱신**

---

## 📎 사용 기술

* Java
* DFS / 백트래킹
* 시뮬레이션

---

필요하다면 👉 **중복 조합 제거 버전**, **BFS로 바이러스 확산하는 개선 코드**, **시간 최적화 포인트 설명**도 같이 정리해줄게 👍
# 🧪 백준 14502번 연구소

## 📌 문제 요약

연구소는 `N x M` 크기의 격자로 이루어져 있으며,

* `0` : 빈 칸
* `1` : 벽
* `2` : 바이러스

가 주어진다. 빈 칸 중 **3곳에 벽을 새로 세운 뒤**, 바이러스가 상하좌우로 퍼졌을 때 **안전 영역(0의 개수)의 최댓값**을 구하는 문제이다.

---

## 💡 풀이 아이디어

이 문제는 크게 두 단계로 나누어 해결한다.

1. **벽 3개를 세우는 모든 경우 탐색**
2. **각 경우마다 바이러스 확산을 시뮬레이션**

격자의 크기가 최대 `8 x 8`로 작기 때문에, **완전 탐색 + DFS** 전략이 충분히 가능하다.

---

## 🧠 접근 방법

### 1️⃣ 벽 세우기 (DFS + 백트래킹)

* 빈 칸(`0`)을 하나씩 벽(`1`)으로 바꾸며 DFS 수행
* 벽을 3개 세우면 더 이상 탐색하지 않고 시뮬레이션 단계로 이동
* DFS 종료 후에는 다시 원상 복구하여 다음 경우를 탐색 (백트래킹)

```java
public static void dfs(int depth) {
    if (depth == 3) {
        // 시뮬레이션 수행
        return;
    }
    
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (map[i][j] == 0) {
                map[i][j] = 1;
                dfs(depth + 1);
                map[i][j] = 0; // 백트래킹
            }
        }
    }
}
```

---

### 2️⃣ 맵 복사

* 벽 배치마다 **기존 맵을 훼손하지 않기 위해** 깊은 복사 수행

```java
int[][] copyMap = new int[n][];
for (int i = 0; i < n; i++) {
    copyMap[i] = map[i].clone();
}
```

---

### 3️⃣ 바이러스 확산 (DFS)

* 초기 바이러스 위치를 미리 저장해두고
* 각 바이러스 위치에서 DFS로 상하좌우 전파
* 빈 칸(`0`)을 만나면 바이러스(`2`)로 변경하며 재귀 호출

```java
public static void spread(int[][] map, int x, int y) {
    int[] dx = {1, -1, 0, 0};
    int[] dy = {0, 0, 1, -1};

    for (int d = 0; d < 4; d++) {
        int nx = x + dx[d];
        int ny = y + dy[d];
        if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
            if (map[nx][ny] == 0) {
                map[nx][ny] = 2;
                spread(map, nx, ny);
            }
        }
    }
}
```

---

### 4️⃣ 안전 영역 계산

* 바이러스 확산이 끝난 후
* 맵 전체를 순회하며 `0`의 개수를 카운트
* 최댓값 갱신

---

## ⏱️ 시간 복잡도

* 벽을 세우는 경우의 수: 최대 `C(64, 3)`
* 각 경우마다 바이러스 확산: `O(N × M)`

➡️ 전체적으로 제한 시간 내 충분히 통과 가능

---

## ✅ 핵심 포인트 정리

* **DFS + 백트래킹**으로 벽 3개 조합 탐색
* **맵 깊은 복사**로 원본 보존
* **재귀 DFS**를 이용한 바이러스 확산
* 안전 영역의 **최댓값 갱신**

---

## 📎 사용 기술

* Java
* DFS / 백트래킹
* 시뮬레이션