# 🐑 백준 16437번 – 양 구출 작전

## 📌 문제 요약

각 섬에는 **양(S)** 또는 **늑대(W)**가 살고 있으며, 섬들은 **트리 구조**로 연결되어 있다.

- 루트는 **1번 섬**
- 루트에서 시작해 아래 섬들을 방문하며 양을 데려온다
- 늑대는 양을 잡아먹는다
- 어떤 경로에서든 **양의 수가 0 이하가 되면 더 이상 데려올 수 없다**

👉 최종적으로 **1번 섬으로 데려올 수 있는 양의 최대 수**를 구하는 문제다.

---

## 💡 해결 아이디어

이 문제는 **트리 + DFS** 유형이다.

핵심 아이디어는 다음과 같다.

- **리프 노드부터 처리해서 위로 올라온다**
- 각 노드에서
  1. 자식 노드들에서 살아남은 양의 수를 모두 합친다
  2. 현재 노드가
     - `S`라면 → 양을 더한다
     - `W`라면 → 양을 뺀다

  3. 결과가 0 이하라면 → `0`으로 처리 (더 이상 데려올 수 없음)

👉 즉, **서브트리 단위로 살아남은 양만 부모로 전달**하는 방식이다.

---

## 🧠 DFS 설계

```java
public static long dfs(int i) {
    long sheep = 0;

    for (int child : children[i]) {
        sheep += dfs(child);
    }

    if (type[i] == 'S') {
        sheep += num[i];
    } else if (type[i] == 'W') {
        sheep -= num[i];
    }

    return (sheep > 0 ? sheep : 0);
}
```

- **리턴값**: 해당 노드의 서브트리에서 최종적으로 살아남은 양의 수
- 양의 수가 음수가 되면 의미 없으므로 `0` 반환

---

## ⚠️ 중요 포인트 — int overflow 주의

처음에는 `int`로 구현했는데 계속 오답이 나왔다.
로직은 맞는데 결과가 이상해서 한참 헤맸다 😇

### 이유

- 양의 수 `num[i]`는 **최대 10⁹**
- 노드 개수는 **최대 123,456개**
- 여러 서브트리에서 양이 합쳐지면 `int` 범위(약 21억)를 쉽게 초과

👉 **누적 합은 반드시 `long`으로 처리해야 한다**

이 부분을 놓쳐서 계속 틀리다가, GPT의 도움을 받고
"아 overflow구나…" 하고 깨달았다 😅

---

## ⏱️ 시간 복잡도

- **O(N)**
- 모든 노드를 DFS로 한 번씩 방문

---

## 📦 자료구조 선택

```java
LinkedList<Integer>[] children;
```

- 각 노드의 자식 노드 관리용
- 트리는 간선이 정확히 `N-1`개이므로 충분히 효율적

---

## ✅ 정리

- 트리 구조 → **DFS**
- 아래에서 위로 양의 수를 합산
- 중간에 음수가 되면 `0`으로 컷
- **누적 합은 무조건 `long` 사용**

👉 문제 자체는 어렵지 않지만,
자료형 선택 하나 때문에 틀리기 딱 좋은 문제였다.
