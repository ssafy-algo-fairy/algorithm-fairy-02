# BOJ 2450 - 모양 정돈

## 📌 문제 설명

1, 2, 3으로만 이루어진 길이 N의 수열이 주어진다.  
이 수열을 **같은 숫자끼리 모이도록** 재배치하려고 한다.

숫자의 순서는 총 6가지 경우가 가능하다.

- (1, 2, 3)
- (1, 3, 2)
- (2, 1, 3)
- (2, 3, 1)
- (3, 1, 2)
- (3, 2, 1)

각 경우에 대해 필요한 **최소 교환 횟수**를 구하고,  
그 중 최솟값을 출력하는 문제이다.

---

## 💡 해결 아이디어

### 1️⃣ 개수 세기

각 숫자의 개수를 센다.

- `num[1]` → 1의 개수
- `num[2]` → 2의 개수
- `num[3]` → 3의 개수

이 개수를 기준으로 구간을 나눈다.

예를 들어 순서가 `(1, 2, 3)`이라면:

- 앞 `num[1]`개 구간 → 1이 와야 함
- 다음 `num[2]`개 구간 → 2가 와야 함
- 마지막 `num[3]`개 구간 → 3이 와야 함

---

### 2️⃣ 잘못 들어간 원소 세기

각 구간에서:

- 다른 숫자가 들어가 있으면 카운트
- 직접 교환 가능한 경우는 먼저 처리
- 남는 것들은 추가 교환 필요

이를 모든 순열(6가지)에 대해 계산하고  
최솟값을 선택한다.

---

## 🔎 시간 복잡도

- 순열 6가지
- 각 경우마다 O(N)

따라서

O(6N) = O(N)

---

## 🧠 핵심 로직

```java
public static int sort(int i1, int i2, int i3) {
    int count = 0;
    int count2 = 0;
    
    for (int i = 0; i < num[i1]; i++) {
        if (input[i] == i2) {
            count++;
            count2++;	
        }
        if (input[i] == i3) count++;
    }
    
    for (int i = num[i1]; i < num[i1] + num[i2]; i++) {
        if (input[i] == i1) {
            if (count2 > 0) count2--;
            else count++;
        }
        if (input[i] == i3) count++;
    }
    
    return count;
}