# 🖥️ 백준 3691번 – 컴퓨터 조립

## 📌 문제 개요

여러 종류의 컴퓨터 부품이 주어질 때,
각 **부품 타입별로 하나씩** 선택하여 컴퓨터를 조립하려고 한다.

* 각 부품은 `가격(price)`과 `품질(quality)`을 가진다.
* 모든 부품 타입에서 **정확히 하나씩** 선택해야 한다.
* 선택한 부품들의 **총 가격은 예산 B를 초과할 수 없다.**
* 이때, 선택한 부품들 중 **최소 품질을 최대화**하는 것이 목표이다.

---

## 🎯 문제의 핵심 포인트

* 모든 타입을 반드시 포함해야 함
* 평가 기준은 **최소 quality (병목 부품)**
* 가격 제한이 있으므로 단순히 최고 품질을 고를 수는 없음

즉,

> **"예산 안에서 구성 가능한 컴퓨터 중, 가장 품질이 좋은 최소 부품을 만들자"**

---

## 🧠 접근 전략 (현재 코드 기준)

### 1️⃣ 타입별 부품 분류

```java
Map<String, PriorityQueue<Part>> parts
```

* `type`을 key로 사용
* 각 타입마다 **가격 기준 최소 힙(PriorityQueue)** 사용
* 입력 순서와 무관하게 정확히 타입별로 묶을 수 있음

---

### 2️⃣ 초기 컴퓨터 구성

* 각 타입에서 **가장 저렴한 부품**을 하나씩 선택
* 총 가격 `sum` 계산
* 현재 선택된 부품 중 **최소 quality** 를 `minQuality` 로 설정

```java
Map<String, Part> computer
```

---

### 3️⃣ 병목 부품 업그레이드 시도

* 현재 최소 품질을 가진 타입(`minKey`)을 찾음
* 해당 타입에서 다음으로 비싼 부품을 하나씩 꺼내며

  * 품질이 증가하는지 확인
  * 교체 시 예산 `B`를 넘지 않는지 확인

```java
while (!parts.get(minKey).isEmpty()) {
    ...
}
```

* 교체 가능하면:

  * 가격 갱신
  * 최소 품질 재계산
* 예산 초과 시 더 이상 진행 불가

---

## 🧩 자료구조 설명

### 🔹 Part 클래스

```java
static class Part implements Comparable {
    int price, quality;
}
```

* `compareTo`는 **가격 기준 오름차순**
* PriorityQueue에서 가장 싼 부품이 먼저 나옴

---

## ⏱️ 시간 복잡도

* 입력 처리: `O(N log N)`
* 초기 선택: 타입 수를 `K`라 할 때 `O(K log N)`
* 업그레이드 과정은 최악의 경우 모든 부품을 순회
