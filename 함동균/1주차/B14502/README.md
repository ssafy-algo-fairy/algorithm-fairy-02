
# README.md — 연구소(BOJ 14502) 풀이 정리

## 1. 문제 요약
- `N x M (3 ≤ N,M ≤ 8)` 격자 연구소
  - `0`: 빈 칸
  - `1`: 벽
  - `2`: 바이러스
- **새 벽을 정확히 3개** 세운 뒤, 바이러스가 상/하/좌/우로 퍼진다.
- 바이러스가 퍼진 뒤에도 `0`으로 남아있는 칸을 **안전 영역**이라 하고,
  안전 영역의 **최댓값**을 구한다.

---

## 2. 풀이 전략(제공 코드 기준 핵심)
이 풀이는 크게 두 단계로 진행된다.

1) **벽 3개 세우는 모든 경우 탐색(백트래킹)**  
2) 벽을 세운 상태에서 **바이러스 확산을 DFS로 시뮬레이션**하여 감염 칸 수를 세고,
   `안전영역 = (원래 빈칸 수) - (감염된 빈칸 수) - 3` 으로 계산한다.

---

## 3. 핵심 변수/자료구조
- `map[8][8]` : 연구소 지도 (최대 8x8이므로 고정 크기 사용)
- `virus[10][]`, `virus_n` : 초기 바이러스 좌표 목록(최대 10개)
- `safe` : **초기 빈 칸(0)의 개수**
- `max` : 안전 영역 최댓값
- `virus_max` : 현재 벽 배치에서 **감염된 빈 칸 수(전파로 2가 된 칸 수)**

---

## 4. 벽 설치(조합) — `wall(i, j, w)`
`w`는 지금까지 세운 벽 개수.

### 동작
- `w == 3`이면:
  - `check()`로 바이러스 확산 시뮬레이션
  - 안전 영역 계산 결과로 `max` 갱신
  - `clear()`로 지도 복구 후 반환

### 중복 조합 방지 방식
- 현재 좌표 `(i, j)`부터 오른쪽으로 먼저 탐색:
  - `for (k = j; k < m; k++)`
- 그 다음 행으로 넘어가며 전체 탐색:
  - `for (k = i+1; k < n; k++) for (l = 0; l < m; l++)`

즉, “이전 위치로 돌아가서 다시 뽑는” 중복을 방지하는 형태로 조합을 만든다.

---

## 5. 바이러스 확산 시뮬레이션 — `check()` + `dfs(i, j)`
### `check()`
- `virus_max = 0` 초기화
- 초기 바이러스 좌표들에 대해 `dfs(virus[i])` 수행
- 안전 영역 반환:
  - `safe - virus_max - 3`

### `dfs(i, j)`
- 4방향(`delta`)으로 인접한 빈 칸(0)을 찾아 감염(2) 처리하며 확산
- 감염 시:
  - `map[di][dj] = 2`
  - `virus_max++`
  - 재귀 DFS 진행

### 가지치기(Pruning)
```java
if (safe - virus_max - 3 <= max) return;
````

* “현재까지 감염이 퍼진 상황에서 남을 수 있는 안전영역의 상한”이 이미 `max` 이하라면
  더 퍼뜨려봐야 답이 개선되지 않으므로 탐색을 중단한다.
* 브루트포스 + DFS 시뮬레이션에서 성능을 끌어올리는 포인트.

---

## 6. 상태 복구 — `clear()`

이 코드는 매 벽 배치마다 “임시 배열 복사” 대신 **원본 지도를 복구**하는 방식을 쓴다.

1. 현재 `map`에서 값이 `2`인 칸을 전부 `0`으로 되돌림
2. 저장해둔 초기 바이러스 좌표(`virus[]`)만 다시 `2`로 복원

이렇게 하면 DFS 확산으로 생긴 감염 흔적만 정리하고,
벽 설치/해제는 `wall()`에서 직접 `map[i][j] = 1 → 0`으로 원복한다.

---

## 7. 정답 계산식 정리

* `safe` = 초기 빈 칸 수(0의 개수)
* `virus_max` = 전파로 새롭게 감염된 빈 칸 수(0 → 2가 된 칸 수)
* 새로 세운 벽 3개는 원래 빈 칸 3개를 차지하므로 안전 영역에서 반드시 제외

따라서,

* **안전 영역 = `safe - virus_max - 3`**

---

## 8. 시간 복잡도 추산

* 격자 최대 64칸, 빈 칸에서 3개 뽑는 조합 수는 최대 `C(64,3) ≈ 41664`
* 각 조합마다 DFS 확산은 최대 64칸 탐색 수준
* 가지치기까지 포함하면 충분히 통과 가능한 범위

---

## 9. 오늘의 학습 포인트

* 작은 범위(N,M ≤ 8)는 **완전탐색(조합)** + **시뮬레이션(DFS/BFS)** 가 정석이다.
* “안전영역 계산”을 **빈 칸 기준(`safe`)으로 잡으면** 결과 계산이 단순해진다.
* 매번 배열을 복사하지 않고도,

  * 감염(2)만 지우고 초기 바이러스만 복원하는 `clear()`
  * 벽은 설치/해제를 백트래킹으로 원복
    이런 방식으로 상태 관리를 할 수 있다.
* `safe - virus_max - 3 <= max` 같은 **상한 기반 가지치기**가 체감 성능을 크게 올린다.

---
