
# README.md — 알파벳 보드 탐색 (DFS + 백트래킹) 풀이 정리

## 1. 문제 요약
- 세로 `R`칸, 가로 `C`칸의 보드가 주어진다. (`1 ≤ R, C ≤ 20`)
- 각 칸에는 **대문자 알파벳** 하나가 적혀 있다.
- 말은 **좌측 상단 (1,1)** 에서 시작한다.
- 말은 **상·하·좌·우** 인접한 칸으로 이동할 수 있다.
- 단, **지금까지 지나온 모든 칸의 알파벳과 중복되는 알파벳이 있는 칸으로는 이동할 수 없다.**
- 목표: 말이 **지날 수 있는 최대 칸 수**를 구한다.  
  (시작 칸 포함)

---

## 2. 핵심 아이디어 (DFS + 백트래킹)
이 문제는 전형적인 **완전 탐색 + 백트래킹** 문제이다.

- 말이 이동할 수 있는 모든 경로를 탐색하되,
- 이미 사용한 알파벳은 다시 사용할 수 없도록 **방문 체크**를 한다.
- 가능한 모든 경로 중에서 **가장 길게 이동한 칸 수의 최댓값**을 구한다.

보드 크기는 최대 `20 × 20 = 400`이지만,
- 알파벳은 **대문자 26개**뿐이므로
- 실제 탐색 깊이는 **최대 26**으로 제한된다.

---

## 3. 상태 정의
DFS에서 관리해야 할 핵심 상태는 다음과 같다.

- `(r, c)` : 현재 말의 위치
- `count` : 현재까지 지나온 칸 수
- `visited[26]` : 이미 사용한 알파벳 여부

```text
visited[i] == true  → 알파벳 ('A' + i)를 이미 사용함
````

---

## 4. 탐색 방법 (DFS)

현재 위치 `(r, c)`에서 다음을 반복한다.

1. 상·하·좌·우 네 방향에 대해 이동 시도
2. 이동할 좌표가 보드 범위 내인지 확인
3. 해당 칸의 알파벳이 **아직 사용되지 않았다면**

   * 방문 처리
   * DFS 재귀 호출
   * 재귀가 끝나면 방문 해제 (백트래킹)

이 과정을 통해 모든 가능한 경로를 탐색한다.

---

## 5. 코드 흐름 요약 (제공 코드 기준)

### (1) 입력 처리

* `BufferedReader`로 `R`, `C` 입력
* `char[][] board`에 보드 정보 저장
* 알파벳 방문 여부를 관리할 `boolean[26]` 배열 생성

---

### (2) 초기 상태 설정

* 시작 위치는 `(0, 0)`
* 시작 칸의 알파벳을 방문 처리
* DFS를 `count = 1`로 시작

---

### (3) DFS 재귀 함수

DFS 함수의 역할:

* 현재 위치에서 갈 수 있는 모든 경로를 탐색
* 이동이 불가능한 경우, 현재 `count`로 최댓값 갱신

핵심 로직:

```java
max = Math.max(max, count);
```

---

### (4) 백트래킹 처리

DFS 호출 이후에는 반드시:

* 방문했던 알파벳을 다시 `false`로 되돌려야 한다.

이 과정을 통해 다른 경로 탐색에 영향을 주지 않는다.

---

### (5) 정답 출력

* 모든 탐색이 끝난 후
* 전역 변수로 관리한 `max` 값을 출력

---

## 6. 시간 / 공간 복잡도

### 시간 복잡도

* 최악의 경우: 알파벳 26개를 모두 사용하는 경로
* 각 단계마다 최대 4방향 탐색

→ **O(4^26)** 처럼 보이지만
실제로는 **알파벳 중복 제한**으로 인해 탐색 수가 급격히 줄어든다.

👉 제한 내에서 충분히 통과 가능

---

### 공간 복잡도

* 방문 배열: `O(26)`
* 재귀 호출 스택: 최대 깊이 `26`

→ **O(26)** 수준

---

## 7. 오늘의 학습 포인트 / 회고

* 이 문제의 핵심은 **좌표 방문이 아니라 알파벳 방문 관리**라는 점이다.
* 일반적인 격자 DFS 문제와 달리,

  * `visited[r][c]`가 아닌
  * `visited[alphabet]`을 사용해야 한다.
* 백트래킹에서 **방문 해제 타이밍**이 매우 중요하다.
* 알파벳 개수가 작기 때문에 **완전 탐색이 가능**하다는 점을 떠올리는 것이 관건이다.

---

## 8. 사용한 입출력 방식

* 입력: `BufferedReader`
* 출력: `System.out.println(max)`

---
