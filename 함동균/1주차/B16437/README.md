
# README.md — 양 구출 작전(BOJ 16437) 풀이 정리

## 1. 문제 요약
- 섬이 `N`개 있고, **각 섬에서 1번 섬으로 가는 경로는 유일**하다 → 전체 구조는 **트리**
- 1번 섬: 구명보트만 존재
- 2번 ~ N번 섬:
  - `S ai` : 양 `ai`마리
  - `W ai` : 늑대 `ai`마리
- 양들은 **자기 섬 → 부모 섬 → … → 1번 섬**으로 이동
- 늑대는 이동하지 않고, **자기 섬에 도착한 양만 잡아먹음**
  - 늑대 1마리당 양 1마리까지
- 목표: **최종적으로 1번 섬에 도달할 수 있는 양의 수**

---

## 2. 핵심 관찰
- 모든 섬에서 1번 섬으로 가는 경로가 유일 → **트리 + 루트 = 1**
- 양은 위로 올라가고, 늑대는 아래에서 기다리며 “통과하는 양”을 잡아먹음
- 즉, **아래 서브트리에서 올라온 양의 총합과 현재 섬의 늑대 수를 비교**하면 된다.

👉 이 문제는 **루트가 1인 트리에서의 DFS + 누적 계산 문제**이다.

---

## 3. 풀이 전략 (제공 코드 기준)
### 접근 방식: **후위 순회 DFS (Post-order)**
- 자식 섬들에서 살아남은 양의 수를 모두 받아온 뒤,
- 현재 섬의 늑대가 양을 잡아먹고,
- 살아남은 양만 부모 섬으로 전달

---

## 4. 상태 정의
- `dfs(i)` : **i번 섬에서 부모로 전달할 수 있는 양의 수**

### 섬 타입에 따른 처리
- 양 섬 (`S ai`)
  - 기본적으로 `ai`마리의 양을 보유
- 늑대 섬 (`W ai`)
  - `ai`마리의 늑대가 있음 → 아래에서 올라온 양을 잡아먹음

---

## 5. DFS 로직 상세
```text
dfs(i):
  totalSheep = 0

  for child in children[i]:
      totalSheep += dfs(child)

  if island i has sheep (S ai):
      totalSheep += ai

  if island i has wolves (W ai):
      totalSheep = max(0, totalSheep - ai)

  return totalSheep
````

### 중요한 점

* **늑대가 더 많으면 양은 0마리만 남음**
* 음수가 되지 않도록 `max(0, …)` 처리
* 모든 계산은 `long` 사용 (ai 최대 10⁹, N 최대 12만)

---

## 6. 자료구조 설계

* `ArrayList<Integer>[] tree` : 트리 인접 리스트 (부모 → 자식)
* `char[] type` : 섬 타입 (`S` / `W`)
* `long[] count` : 섬에 있는 양 또는 늑대 수
* DFS는 **1번 섬부터 시작**

---

## 7. 최종 정답

* `dfs(1)`의 반환값이
  👉 **1번 섬에 최종적으로 도달한 양의 수**
* 1번 섬에는 늑대가 없으므로 그대로 출력

---

## 8. 시간 / 공간 복잡도

* 시간 복잡도: **O(N)**

  * 모든 섬을 정확히 한 번씩 DFS 방문
* 공간 복잡도: **O(N)**

  * 트리 저장 + 재귀 스택

---

## 9. 오늘의 학습 포인트

* “경로가 유일하다” → **트리라는 강력한 힌트**
* 누적 문제는 **DFS 후위 순회**로 풀면 깔끔하다
* 값의 범위가 큰 트리 문제에서는:

  * `int` ❌ → `long` ⭕
* 늑대가 양을 “통과하면서” 잡아먹는 구조는

  * **부모로 올라가기 직전에 처리**해야 논리적으로 맞다

---

## 10. 요약 한 줄

> 이 문제는 **루트 트리에서 자식들의 결과를 누적하며 늑대를 차감하는 DFS 문제**이며,
> 후위 순회로 “살아남은 양만 위로 전달”하는 것이 핵심이다.


