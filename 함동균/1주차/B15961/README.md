# README.md — 회전 초밥(BOJ 2531) 풀이 정리

## 1. 문제 요약
- 길이 `N`의 원형 벨트 위에 초밥 접시가 순서대로 놓여 있다.
- 임의의 시작 위치에서 **연속으로 `k`개** 접시를 먹을 때, 먹은 초밥의 **서로 다른 종류 수**를 최대화하고 싶다.
- 추가로 쿠폰 초밥 `c`를 **무료로 1개 더** 받을 수 있다.
  - 현재 `k`개에 `c`가 없다면, **종류 수가 +1** 증가한다.
- 목표: 가능한 모든 연속 구간(원형 포함) 중 **(쿠폰 포함) 최대 종류 수**를 출력.

---

## 2. 핵심 아이디어: 슬라이딩 윈도우 + 카운팅 배열
`N`이 최대 3,000,000으로 매우 커서, 모든 구간을 매번 set으로 세면 시간 초과가 난다.

따라서:
- 현재 윈도우(연속 `k`개)에서 각 초밥 종류의 등장 횟수를 `selected[type]`로 관리한다.
- 윈도우를 한 칸씩 이동할 때:
  - 빠지는 접시 1개 감소
  - 들어오는 접시 1개 증가
- “서로 다른 종류 수”는 `selected[x]`가 0→1 되면 +1, 1→0 되면 -1로 관리한다.

---

## 3. 상태 정의(제공 코드 기준)
- `dish[i]` : i번째 위치의 초밥 종류 (1..d)
- `selected[t]` : 현재 윈도우에서 종류 `t`가 몇 번 등장하는지
- `num_sel` : 현재 윈도우의 **서로 다른 종류 수**
- `max_sel` : 가능한 모든 윈도우 중 **(쿠폰 포함) 최대 종류 수**
- 윈도우 포인터:
  - `start` : 윈도우 시작 인덱스
  - `end` : 윈도우 끝 인덱스 (원형이므로 `% n` 적용)

---

## 4. 알고리즘 흐름
### (1) 초기 윈도우 구성 (0 ~ k-1)
1. `selected[dish[i]]`가 0이면 새로운 종류이므로 `num_sel++`
2. `selected[dish[i]]++`
3. 쿠폰 반영:
   - 현재 윈도우에 `c`가 없으면 `num_sel + 1`
   - 있으면 `num_sel`
4. `max_sel` 갱신

### (2) 슬라이딩 윈도우를 원형으로 한 칸씩 이동 (총 n-1번)
각 이동마다 다음을 수행:
1. **빠지는 접시 처리**
   - `selected[dish[start]]--`
   - 만약 0이 되면 해당 종류가 사라진 것이므로 `num_sel--`
2. `start = (start + 1) % n`
3. **들어오는 접시 처리**
   - `end = (end + 1) % n`
   - 만약 들어오는 종류가 0이었다면 `num_sel++`
   - `selected[dish[end]]++`
4. 쿠폰 반영 후 `max_sel` 갱신

### (3) 출력
- 최종 `max_sel` 출력

---

## 5. 쿠폰 처리 포인트
각 윈도우에서 최종 종류 수는 아래 중 큰 값이 아니라 “쿠폰 포함 조건”으로 결정된다.

- `selected[c] == 0` 이면: `num_sel + 1`
- 아니면: `num_sel`

즉, 쿠폰 초밥이 윈도우에 **없을 때만 +1**.

---

## 6. 시간 / 공간 복잡도
- 시간 복잡도: **O(N)**
  - 윈도우를 `N`번 미끄러뜨리며 각 단계는 O(1)
- 공간 복잡도: **O(d)**
  - `selected` 배열 크기 `d+1` (최대 3001)

---

## 7. 오늘의 학습 포인트(요약)
- `N`이 매우 큰 “연속 구간 최댓값” 문제는 대부분 **슬라이딩 윈도우**가 정석이다.
- 종류 개수를 빠르게 갱신하려면 `HashSet` 대신 **카운팅 배열 + distinct 카운터(num_sel)** 구조가 효율적이다.
- 원형 배열은 실제로 두 배로 늘리지 않고도, 인덱스를 **`% n`** 로 처리하면 깔끔하게 구현 가능하다.
- 쿠폰은 “현재 윈도우에 포함되었는지 여부”만 중요하므로 `selected[c] == 0` 체크로 처리한다.

---
