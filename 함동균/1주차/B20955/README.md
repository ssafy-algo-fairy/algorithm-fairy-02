
# README.md — 뉴런 트리 만들기 (Union-Find / 최소 연산)

## 1. 문제 요약
- 뉴런 `N`개, 시냅스(간선) `M`개가 주어진다.
- 가능한 연산(비용 1씩):
  1) **연결되지 않은 두 뉴런을 연결(간선 추가)**  
  2) **이미 연결된 두 뉴런의 연결을 끊음(간선 삭제)**
- 목표: 전체 뉴런을 **사이클이 없는 연결 그래프(트리)** 로 만들기 위한 **최소 연산 횟수**를 구한다.

---

## 2. 핵심 관찰
트리는 다음 성질을 만족한다.

1) **연결 그래프**
2) **사이클 없음**
3) 간선 개수 = `N - 1`

따라서 현재 그래프를 트리로 만들려면:
- 사이클을 만드는 “불필요한 간선”은 **삭제**해야 하고,
- 여러 컴포넌트로 분리되어 있으면 **추가 연결**이 필요하다.

---

## 3. 풀이 아이디어 (제공 코드 기준)
제공 코드는 **유니온 파인드(DSU)** 로 간선을 하나씩 보며 다음을 센다.

- `connect`: 서로 다른 컴포넌트를 실제로 **합친 간선 수**(성공한 union 수)
- `cut`: 같은 컴포넌트 내부를 잇는 간선(= 사이클을 만드는 간선)이 들어오면
  → 이 간선은 트리를 만들 때 **삭제해야 하므로 `cut++`**

### DSU 처리 로직
- `unite(a, b)`에서 `find(a) == find(b)`이면:
  - 이미 연결된 내부 간선 → 사이클 발생 → `cut++`
- 아니면:
  - 컴포넌트를 연결하는 간선 → `connect++` 후 union

---

## 4. 정답 공식 유도
DSU로 모든 간선을 처리한 뒤:

### (1) 사이클 제거 비용
- 같은 컴포넌트 내부 간선들은 모두 트리에서 불필요(사이클 원인)
- 최소 삭제 횟수 = `cut`

### (2) 컴포넌트 연결 비용
성공한 union이 `connect`번 일어났다면,
- 남은 컴포넌트 수 = `N - connect`
  - (처음 N개 컴포넌트에서, 합칠 때마다 1씩 감소)

트리는 전체가 1개 컴포넌트여야 하므로,
- 필요한 추가 간선 수 = `(컴포넌트 수 - 1) = (N - connect - 1)`
- 이는 그대로 **추가 연산 횟수**가 된다.

### (3) 총 최소 연산 횟수
```

total = cut + (N - connect - 1)
= (N - 1) - connect + cut

````

제공 코드의 출력:
```java
System.out.println((n - 1) - connect + cut);
````

와 정확히 일치한다.

---

## 5. 왜 이것이 “최소”인가?

* 사이클이 있으면 트리가 될 수 없으므로, 각 사이클을 끊기 위한 **삭제는 반드시 필요**.
  DSU에서 `cut`으로 잡히는 간선들은 “스패닝 포리스트(acyclic)” 관점에서 **절대 포함될 수 없는 간선**이므로,
  이들을 삭제하는 것이 최소 삭제 수가 된다.
* 사이클을 제거해도 컴포넌트가 여러 개면 연결 그래프가 아니므로,
  컴포넌트를 1개로 만들기 위해서는 최소 `컴포넌트-1`개의 간선 추가가 필요하다.
* 따라서 `cut + (컴포넌트-1)`는 하한이면서 동시에 달성 가능한 값 → 최소.

---

## 6. 시간/공간 복잡도

* DSU(경로 압축 + union by rank 유사):

  * 시간: `O((N+M) α(N))` (거의 선형)
  * 공간: `O(N)`

---

## 7. 구현 포인트

* `N, M`이 최대 100,000이므로 DSU로 충분히 처리 가능.
* `size[]`는 랭크(혹은 트리 높이) 비슷하게 사용하여 union을 최적화.
* 입력은 `BufferedReader + StringTokenizer`로 처리.

---

## 8. 오늘의 학습 포인트 요약

* “트리로 만들기” 문제는 보통

  1. **사이클 제거(삭제)**
  2. **컴포넌트 연결(추가)**
     두 비용을 분리해서 생각하면 깔끔하다.
* DSU로 간선을 보며

  * **스패닝 포리스트에 포함되는 간선 수(`connect`)**
  * **불필요한 간선 수(`cut`)**
    를 동시에 구할 수 있다.
* 최종 정답은 `cut + (N - connect - 1)`.

---

