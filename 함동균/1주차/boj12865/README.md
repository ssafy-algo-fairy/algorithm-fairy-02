# 12865. 평범한 배낭(0/1 Knapsack) 풀이 정리

## 1. 문제 요약
- 물건 `N`개가 있고, 각 물건은 **무게 W**, **가치 V**를 가진다.
- 배낭은 최대 무게 `K`까지 담을 수 있다.
- 각 물건은 **최대 1번만** 선택 가능(= 0/1 배낭).
- 목표: **총 무게 ≤ K**를 만족하면서 **가치 합의 최댓값**을 구한다.

---

## 2. 핵심 아이디어 (DP)
이 문제는 전형적인 **0/1 Knapsack**으로,  
`dp[무게] = 해당 무게 한도 내에서 얻을 수 있는 최대 가치` 로 정의하면 된다.

### DP 정의
- `dp[j]` : 배낭 허용 무게가 `j`일 때 얻을 수 있는 최대 가치

### 점화식(전이)
어떤 물건 `(w, v)`를 고려할 때,

- 물건을 **안 넣는 경우**: `dp[j]`
- 물건을 **넣는 경우**: `dp[j - w] + v`

따라서,
- `dp[j] = max(dp[j], dp[j - w] + v)`  (단, `j >= w`)

### 중요한 구현 포인트: 역순 루프
0/1 배낭에서는 같은 물건을 중복 사용하면 안 되므로,
- `j`를 `K → w`로 **역순**으로 돌려야 한다.
( dp[j - w] 가 dp[j] 보다 먼저 갱신되면 안 되므로 )

즉,
- `for (j = K; j >= w; j--)`

---

## 3. 코드 흐름 요약 (제공 코드 기준)
### (1) 입력 처리
- `BufferedReader` + `StringTokenizer`로 빠르게 입력 처리
- `n`, `k` 입력 후, `dp` 배열 크기를 `k+1`로 생성

### (2) 첫 번째 물건을 따로 초기화
제공 코드에서는 첫 물건을 먼저 읽어서 아래처럼 초기값을 세팅한다.

- 첫 물건 `(w, v)`에 대해:
  - `dp[i] = v` (for `i = w..K`)
  - 의미: 첫 물건만 고려했을 때, 무게가 `w` 이상이면 최소 `v` 가치는 확보 가능

### (3) 나머지 물건들에 대해 0/1 전이 수행
- 이후 `n-1`개의 물건에 대해:
  - `for (j = K; j >= w; j--)`
  - `dp[j] = max(dp[j], dp[j - w] + v)`

### (4) 정답 출력
- 최종적으로 `dp[K]` 출력

---

## 4. 시간/공간 복잡도
- 시간 복잡도: **O(N × K)**  
  - 최대 `100 × 100,000 = 10,000,000` 정도로 자바에서 충분히 가능
- 공간 복잡도: **O(K)**  
  - 2차원 DP 대신 1차원 DP로 최적화

---

## 5. 오늘의 학습 포인트 / 회고
- 이 문제는 “평범한 배낭”이라는 이름 그대로 **0/1 배낭 DP의 정석**을 요구한다.
- 핵심은:
  1) `dp[무게]` 정의를 정확히 잡는 것  
  2) **역순 루프**로 중복 선택을 막는 것  
  3) 2D → 1D로 공간 최적화하는 것

- 제공 코드에서는 첫 번째 물건을 별도 초기화했지만,
  일반적으로는 모든 물건을 동일한 루프로 처리해도 된다(초기 dp는 0으로 시작).

---

## 6. 사용한 입출력 방식
- 입력: `BufferedReader`, `StringTokenizer`
- 출력: `System.out.println(dp[k])`

---
