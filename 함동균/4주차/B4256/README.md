# README.md — 트리 (BOJ 4256)

## 1. 문제 요약
- 이진 트리의 **전위 순회(preorder)** 결과와 **중위 순회(inorder)** 결과가 주어진다.
- 이 두 순회 결과로 만들어지는 트리는 항상 **유일**하다.
- 목표: 해당 트리를 **후위 순회(postorder)** 했을 때의 방문 순서를 출력한다.
- 테스트케이스 T개, 각 케이스에서 n ≤ 1000.

---

## 2. 핵심 아이디어
전위/중위 순회의 성질을 이용해 트리를 재귀적으로 분할한다.

- 전위 순회: `루트 → 왼쪽 → 오른쪽`
  - 현재 구간의 **맨 앞 값이 루트**
- 중위 순회: `왼쪽 → 루트 → 오른쪽`
  - 루트의 위치를 기준으로 **왼쪽 서브트리 / 오른쪽 서브트리**가 나뉜다.

후위 순회는 `왼쪽 → 오른쪽 → 루트` 이므로,
재귀적으로 왼쪽/오른쪽을 처리한 뒤 마지막에 루트를 출력하면 된다.

---

## 3. 재귀 분할(트리 직접 생성 없이 출력)
한 서브트리를 다음 4개 구간으로 표현한다.

- 전위 구간: `[preL .. preR]`
- 중위 구간: `[inL .. inR]`

### 처리 절차
1) 루트는 전위 구간의 첫 원소다.
2) 그 루트가 중위 구간에서 등장하는 위치를 찾는다. (중위 배열을 구간 내에서 선형 탐색)
3) 중위에서 루트 기준으로 왼쪽 길이(`leftSize`)를 구한다.
4) 그 길이를 이용해 전위 구간도 왼쪽/오른쪽으로 같은 크기로 쪼갠다.
5) **왼쪽 재귀 → 오른쪽 재귀 → 루트 출력** 순서로 진행한다.

---

## 4. 출력 방식(코드 스타일)
- 보통은 `BufferedWriter` 같은 출력 스트림에 결과를 바로 기록한다.
- 테스트케이스마다 한 줄에 후위 순회 결과를 공백으로 구분해 출력한다.
- 마지막에 개행을 출력한다.

---

## 5. 시간 복잡도
- 매 재귀에서 “루트가 중위에서 어디 있는지”를 구간 내 선형 탐색하면,
  최악의 경우 O(n^2)까지 갈 수 있다.
- 하지만 이 문제는 n ≤ 1000이라 O(n^2)도 충분히 통과 가능하다.

공간은 배열 + 재귀 깊이로 O(n).

---

## 6. 오늘의 학습 포인트
- 전위/중위만으로 트리를 복원할 수 있는 이유는
  - 전위가 **루트를 먼저 제공**하고
  - 중위가 **루트 기준 좌/우를 분리**해주기 때문이다.
- 트리를 실제 노드 객체로 만들 필요 없이,
  “배열 구간 인덱스만 유지”해도 후위를 바로 출력할 수 있다.

---