# README.md — 독특한 우선순위 수식 계산 풀이 정리

## 1. 문제 요약
길이 최대 `10^6`인 수식(숫자와 연산자 `+ - * /`)이 주어진다.  
다음 규칙으로 수식을 순차적으로 줄여가며 최종 값을 구한다.

### 계산 규칙
1. **맨 앞 연산자** 또는 **맨 뒤 연산자** 중 하나를 선택해 먼저 계산한다.  
   - 단, **음수 부호는 연산자가 아님** (예: `-1-1` 가능, `2+-3` 불가)
2. `*`, `/`는 `+`, `-`보다 우선순위가 높다.
3. 우선순위가 같다면, **해당 연산을 수행했을 때 결과가 더 큰 것**을 먼저 계산한다.
4. 결과값도 같다면 **앞쪽(맨 앞 연산자)** 을 먼저 계산한다.
5. 나눗셈은 **C++ 정수 나눗셈(trunc toward 0)** 규칙과 동일.

출력은 최종 정수(불필요한 leading zero 제거).

---

## 2. 핵심 아이디어 (제공 코드 기준)
수식 길이가 매우 크므로, 매번 문자열을 자르거나 삽입하는 방식은 불가능하다.  
따라서 수식을 다음처럼 분해하고, “앞/뒤에서 하나씩 줄여가는” 방식으로 처리한다.

- 숫자들: `A0, A1, ..., Ak`
- 연산자들: `op0, op1, ..., op(k-1)`  
  (항상 숫자와 연산자가 번갈아 등장)

그리고 매 단계마다:
- **앞 연산자** `A_L op_L A_(L+1)`
- **뒤 연산자** `A_(R-1) op_(R-1) A_R`
두 후보 중에서 규칙에 따라 하나를 선택하여 계산하고,
그 결과로 숫자 하나를 줄인다.

즉, 전체는 “구간 [L..R]”를 유지하면서
- 앞을 계산하면 `A_L` 자리에 결과를 넣고 `L+1`을 제거
- 뒤를 계산하면 `A_R` 자리에 결과를 넣고 `R-1`을 제거
하는 식으로 `R-L`을 1씩 줄여 최종 1개 숫자를 남긴다.

---

## 3. 데이터 구조 설계
### 3.1 파싱
- 입력 문자열을 한 번 훑어서:
  - `long[] nums` (또는 `long` 리스트)
  - `char[] ops`
로 분리 저장
- **맨 앞 숫자만 음수 가능**하므로 파싱 시 첫 토큰만 `-`를 부호로 처리

### 3.2 투 포인터
- `L = 0`, `R = numsCount - 1`
- `opL = L`, `opR = R-1` 개념으로 연산자 위치를 함께 추적

이 구조로 매 단계 `O(1)`에 앞/뒤 후보를 평가할 수 있어 전체 `O(N)`이 된다.

---

## 4. “어떤 쪽을 먼저 계산할지” 결정 로직
각 단계에서 다음 값을 구한다.

### 4.1 우선순위 비교
- `prio('*') = prio('/') = 1`
- `prio('+') = prio('-') = 0`

앞 후보의 우선순위가 더 높으면 앞 계산,
뒤 후보가 더 높으면 뒤 계산.

### 4.2 우선순위가 같으면 결과값 비교
- `frontRes = calc(nums[L], ops[L], nums[L+1])`
- `backRes  = calc(nums[R-1], ops[R-1], nums[R])`

규칙에 따라:
- `frontRes` vs `backRes` 중 **더 큰 결과를 만드는 연산**을 먼저 수행
- 같다면 **앞 연산(맨 앞)** 우선

---

## 5. 연산 구현(주의점)
### 5.1 정수 나눗셈
문제의 나눗셈은 C++과 같은 “0 방향 절삭(trunc toward 0)”
- Java의 정수 나눗셈도 동일하게 0 방향 절삭이므로 그대로 사용 가능
- 단, 0으로 나누는 경우는 입력에서 보장되지 않음

### 5.2 오버플로우
- 계산 중 모든 수는 `[-2^63, 2^63)` 범위라고 보장 → `long` 사용

---

## 6. 복잡도
- 파싱: `O(|expr|)`
- 매 단계에서 한 번의 비교 + 한 번의 계산으로 숫자 개수를 1씩 줄임
  - 총 연산 횟수는 연산자 개수 `K`번 → `O(K)`
- 전체 시간: **O(|expr|)**
- 공간: 숫자/연산자 저장에 **O(|expr|)** (실질적으로 토큰 수)

---

## 7. 오늘의 학습 포인트(요약)
- “앞 또는 뒤에서만 선택” 같은 규칙은 **Deque/Two-pointer 모델링**이 핵심이다.
- 매 단계마다 전체를 다시 탐색하면 무조건 터지므로,  
  **앞/뒤 후보만 평가 가능한 구조**로 문제를 재정의해야 한다.
- 우선순위 → 결과 비교 → 위치(앞 우선) 순의 tie-break 규칙은  
  “비교 함수”로 분리하면 구현 실수가 줄어든다.
- 길이 10^6급 문자열 문제는:
  - 문자열 조작 금지
  - 1-pass 파싱 + O(1) 갱신 구조가 정답 패턴이다.

---