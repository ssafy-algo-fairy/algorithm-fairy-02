# README.md — 홍익 투어리스트(명소 관리) 풀이 정리

## 1. 문제 요약
- 구역 `N`개가 **원형**으로 배치되어 있고, 도현이는 현재 위치에서 **시계방향**으로만 이동한다.
- 명소 여부는 토글될 수 있으며, 아래 쿼리를 처리한다.

### 쿼리
1. `1 i` : i번 구역의 명소 여부 **토글**
2. `2 x` : 현재 위치를 시계방향으로 `x`만큼 이동 (`x`는 매우 큼)
3. `3` : 현재 위치에서 **명소까지 시계방향 최소 이동 칸 수** 출력  
   - 명소가 없으면 `-1`

---

## 2. 핵심 아이디어
- 원형에서 “현재 위치 기준으로 시계방향으로 가장 가까운 명소”를 빠르게 찾으려면  
  **정렬된 집합에서 현재 위치 이상인 첫 원소(ceiling)** 를 찾으면 된다.
- 명소는 토글되므로 삽입/삭제가 빠른 자료구조가 필요 → **TreeSet 사용**

---

## 3. 사용 자료구조 (제공 코드 기준)
- `boolean[] myungso`  
  - 각 인덱스(0-based)가 명소인지 여부를 O(1)에 확인/토글하기 위해 사용
- `TreeSet<Integer> tree`  
  - 명소인 구역들의 **인덱스(0-based)** 를 정렬 상태로 유지
  - 주요 연산:
    - `add`, `remove` : O(log N)
    - `ceiling(x)` : x 이상인 최소 원소 O(log N)
    - `first()` : 최솟값 O(log N) (또는 내부적으로 O(1) 수준)

---

## 4. 알고리즘 흐름
### 초기화
- 입력 수열 `A`를 읽으며 `A[i] == 1`이면:
  - `tree.add(i)`
  - `myungso[i] = true`

현재 위치 `now`는 0(=1번 구역)에서 시작.

---

## 5. 쿼리 처리 로직
### 1) `1 i` (명소 토글)
- 입력은 1-based → 코드에서 `loc = i - 1`로 0-based 변환
- 현재 명소라면 `tree.remove(loc)`, 아니면 `tree.add(loc)`
- `myungso[loc] = !myungso[loc]` 로 상태 갱신

✅ 토글을 `TreeSet`만으로도 가능하지만,  
`boolean[]`을 함께 둬서 “현재 명소인지”를 O(1)에 안정적으로 판단한다.

---

### 2) `2 x` (이동)
- 원형이므로 `now = (now + x) % n`
- `x`가 최대 `1e9`라도 `% n`으로 안전하게 처리

---

### 3) `3` (가장 가까운 명소까지 거리)
1. 명소가 하나도 없으면 `-1`
2. 있으면 `next = tree.ceiling(now)`로 현재 위치 이상에서 가장 가까운 명소를 찾는다.
   - `next != null`이면 답은 `next - now`
   - `next == null`이면, 현재 위치 이후에는 명소가 없다는 뜻이므로
     - 원형으로 돌아가 `tree.first()`까지 가야 한다.
     - 거리 = `(n - now) + tree.first()`

코드에서는 다음과 같이 계산한다:
- `tree.first() + (n - now)`  
  (0-based 기준에서 동일한 의미)

---

## 6. 시간 / 공간 복잡도
- 각 쿼리 연산은 `TreeSet` 기준 **O(log N)**
- 총 시간: **O(Q log N)** (Q ≤ 100,000 이므로 충분)
- 공간: `boolean[N]` + `TreeSet` → **O(N)**

---

## 7. 오늘의 학습 포인트(요약)
- “원형 + 가장 가까운 다음 원소” 문제는  
  **정렬 집합(TreeSet) + ceiling/first** 조합이 정석 패턴이다.
- 이동량이 큰 경우도 `(now + x) % n`으로 처리하면 단순해진다.
- 토글 문제에서는 `boolean[]`으로 상태를 따로 들고 있으면
  삽입/삭제 조건 판단이 명확해져 구현 실수가 줄어든다.

---
