# 🐑🐺 BOJ 16437 - 양 구출 작전

- 🔗 문제 링크: https://www.acmicpc.net/problem/16437
- 🏷️ 분류: 트리 DP, DFS(후위 순회), 그래프(트리)

---

## 📌 문제 요약
1번 섬이 루트인 트리 형태의 섬들이 있다.  
각 섬(2~N)에는 **양(S)** 또는 **늑대(W)** 가 있으며 마리 수가 주어진다.

- 양은 1번 섬으로 이동하며, 이동 경로에서 만나는 늑대는 양을 잡아먹는다.
- 어떤 섬에서든 **지나온(아래 서브트리에서 올라온) 양**이 늑대 수보다 적으면 양은 0마리가 될 수 있다.
- 최종적으로 **1번 섬에 도착하는 양의 수(최대 생존 수)**를 구한다.

---

## 💡 풀이 아이디어
트리에서 **서브트리 단위로 “살아남아 위로 올라가는 양의 수”**를 계산하면 된다.

- 각 노드(섬) `cur`에 대해:
  - 자식 섬들에서 올라온 양의 수를 모두 더한다.
  - 현재 섬이 늑대라면 그 수만큼 양을 감소시킨다(0 미만이면 0).
  - 현재 섬이 양이라면 그 수만큼 양을 증가시킨다.
- 이 값을 부모 섬으로 반환한다.

이 방식은 자식부터 계산해야 하므로 **후위 순회(postorder)** DFS가 자연스럽다.

---

## ✅ 자료구조 / 상태 정의
- `type[i]`
  - `0` : 늑대(W)
  - `1` : 양(S)
- `num[i]` : 해당 섬의 마리 수 (양 또는 늑대)
- `goTo[p]` : p번 섬의 자식 섬 리스트(인접 리스트 형태)

입력에서 `i -> p` 형태로 “i가 p로 이동”이 주어지므로,
트리의 방향을 **부모(p) → 자식(i)** 로 만들어 `goTo[p].add(i)`로 저장한다.

---

## 🔁 DFS (후위 순회) 로직
### 함수: `postorder(cur)`
`postorder(cur)`는 **cur 서브트리에서 살아남아 cur를 거쳐 부모로 올라가는 양의 수**를 반환한다.

1) 자식들에 대해 재귀 호출해, 자식 서브트리에서 올라온 양의 수를 `sum`에 누적
2) 현재 노드 처리
   - 늑대(W)라면: `sum = max(sum - 늑대수, 0)`
   - 양(S)이라면: `sum += 양수`
3) `sum` 반환

---

## 🐺🐑 핵심 처리(늑대/양)
- 늑대 섬: 아래에서 올라온 양을 잡아먹음  
  - `sum - num[cur]`가 음수면 0으로 처리
- 양 섬: 아래에서 올라온 양에 양이 합류  
  - `sum + num[cur]`

이렇게 하면 “서브트리에서 올라오는 양”만 관리하면 되므로 상태가 단순하다.

---

## ⏱️ 복잡도
- 각 노드를 정확히 한 번 방문하고, 각 간선을 한 번씩 따라감

- 시간 복잡도: `O(N)`
- 공간 복잡도: `O(N)` (인접 리스트 + 재귀 스택)

---

## 📝 구현 포인트(코드 기준)
- 마리 수 누적합이 커질 수 있으므로 `long` 사용 (`num`, 반환값 모두 long)
- 루트(1번 섬)는 입력에 타입/수가 주어지지 않으므로 기본값(0)으로 두고,
  `postorder(1)` 결과가 곧 정답이 된다.
- 트리가 깊을 경우 재귀가 깊어질 수 있으니(환경에 따라) 스택 제한이 걱정되면
  반복 DFS로 바꾸는 것도 가능하지만, 보통은 통과한다.

---
