# 📈 BOJ 14002 - 가장 긴 증가하는 부분 수열 4 (LIS 4)

- 🔗 문제 링크: https://www.acmicpc.net/problem/14002
- 🏷️ 분류: DP, 경로 복원(Backtracking)

---

## 📌 문제 요약

수열이 주어졌을 때, **가장 긴 증가하는 부분 수열(LIS)** 의

1. **길이**
2. 그 LIS 중 하나의 **수열 자체**

를 출력하는 문제다.

- “부분 수열”이므로 원소를 **연속으로 고를 필요는 없고**, 순서만 유지하면 된다.
- “증가”는 엄격 증가(`a1 < a2 < ...`)이다.

---

## 💡 풀이 아이디어

이 코드는 전형적인 `O(N^2)` LIS DP에 **이전 인덱스(부모 포인터)** 를 저장하여 수열을 복원한다.

핵심은 다음 2가지다.

- `dp[i][1]`: i번째 원소를 마지막으로 하는 LIS 길이
- `dp[i][2]`: 그 LIS에서 i번째 원소 바로 이전 원소의 인덱스(경로 복원용)

---

## ✅ DP 정의

코드에서 `dp[i]`는 3개의 값을 갖는다.

- `dp[i][0]` : i번째 값(수열 원소)
- `dp[i][1]` : i를 끝으로 하는 LIS의 길이
- `dp[i][2]` : i의 이전 원소 인덱스(부모 인덱스)

즉,

- `dp[i][1] = max(dp[j][1]) + 1`  
  (단, `j < i` 이고 `dp[j][0] < dp[i][0]` 인 경우만)

---

## 🔁 점화식(Transition)

i번째 수 `num`을 읽을 때, 이전 원소 `j (0..i-1)`를 전부 확인한다.

- 조건: `dp[j][0] < num` (증가 조건)
- 그중 `dp[j][1]`(길이)가 가장 큰 j를 선택해서 이어붙인다.

코드 흐름은 다음과 같다.

1. `max_len` : i 이전에서 이어붙일 수 있는 LIS 최대 길이
2. `max_idx` : 그 최대 길이를 만든 이전 인덱스

그리고 i에 대해

- `dp[i][0] = num`
- `dp[i][1] = max_len + 1`
- `dp[i][2] = max_idx`

---

## 🧩 정답(길이) 찾기

DP를 다 채운 뒤,

- `dp[i][1]` 값이 가장 큰 i를 찾아
  - `ans = 최대 길이`
  - `ans_idx = 그때의 인덱스`

---

## 🔙 수열 복원(Backtracking)

`dp[i][2]`가 “이전 인덱스”이므로, `ans_idx`에서 시작해 부모를 따라가면 LIS가 역순으로 나온다.

- `ans_arr[ans-1]`부터 채우기 위해 뒤에서 앞으로 저장
- 매 단계에서 `ans_idx = dp[ans_idx][2]`로 이동

마지막에 `ans_arr`를 앞에서부터 출력하면 LIS가 된다.

---

## ⏱️ 복잡도

- 시간 복잡도: `O(N^2)`
  - 각 i에 대해 모든 j(<i)를 확인
- 공간 복잡도: `O(N)`
  - `dp[N][3]`, `ans_arr[ans]`

---

## 📝 코드 기반 메모 / 개선 포인트(선택)

- 입력이 큰 편이 아니라도, 백준에서는 `Scanner` 대신 `BufferedReader` + 파서가 더 안정적이다.
- `max_idx` 기본값이 0이라서 “이전 원소가 없는 경우”도 0을 가리키게 된다.
  - 현재 코드는 `ans_arr` 채우는 과정에서 길이만큼만 따라가므로 보통 문제 없이 동작한다.
  - 더 명확히 하려면 “부모 없음”을 `-1`로 두고, 복원할 때 `-1`에서 멈추는 방식이 깔끔하다.
- `dp[i][0]`에 수열 값을 그대로 저장하는 대신, 입력 배열 `arr[i]`로 분리해도 가독성이 좋아진다.

---
