# 🌲 BOJ 20955 - 민서의 응급 수술

- 🔗 문제 링크: https://www.acmicpc.net/problem/20955
- 🏷️ 분류: Union-Find(Disjoint Set Union, DSU), 그래프(연결 요소), 사이클 처리

---

## 📌 문제 요약
정점 `N`개와 간선 `M`개가 있는 무방향 그래프가 주어진다.  
이 그래프를 **하나의 트리**로 만들기 위해 필요한 최소 연산 횟수를 구하는 문제다.

- 트리는 **연결 그래프**이며 **사이클이 없다**
- 이미 존재하는 간선들 중 불필요한 간선(사이클을 만드는 간선)은 제거해야 하고
- 분리된 컴포넌트들은 간선을 추가해 하나로 연결해야 한다

---

## ❗ 시행착오 (Union-Find를 몰랐음)
이 문제는 처음에 **Union-Find(DSU)라는 개념을 아예 몰라서**
어떻게 접근해야 할지 감이 안 잡혔다.

그래프의 연결 상태를 빠르게 관리하고,
- “이 간선이 사이클을 만드는지?”
- “현재 연결 요소가 몇 개인지?”

를 처리하려면 DSU가 핵심이었고,
결국 **Union-Find를 찾아보고 공부한 뒤** 해결할 수 있었다.

---

## 💡 풀이 아이디어 (DSU로 사이클 + 컴포넌트 개수 계산)
핵심은 두 가지를 세는 것이다.

1) 🌀 **사이클을 만드는 간선 수**
- 어떤 간선 `(u, v)`가 이미 같은 집합(같은 루트)에 속해 있다면,
  이 간선은 사이클을 만든다 → 제거 대상
- 코드에서는 이런 경우 `cnt++`로 누적

2) 🔗 **연결 요소(컴포넌트) 개수**
- 모든 간선을 처리한 후, 루트의 개수를 세면 현재 컴포넌트 수가 된다
- 컴포넌트가 `C`개라면, 하나로 연결하려면 간선을 `C - 1`개 추가해야 한다

---

## ✅ 정답 계산 방식 (코드 흐름 기준)
코드의 `cnt`는 처음에 “사이클 간선 개수”로 누적되다가,
마지막에 “루트 개수”를 추가로 세는 방식으로 동작한다.

- 간선 입력 처리 중:
  - 같은 루트면 `cnt++` (불필요한 간선 = 제거 횟수 증가)

- 간선 처리 후:
  - 루트 개수(컴포넌트 수)를 `cnt`에 더한다

최종 출력:
- `cnt - 1`

이는 아래와 같은 의미와 같다.

- 제거해야 할 간선 수 = `cycleCnt`
- 연결 요소 수 = `componentCnt`
- 추가해야 할 간선 수 = `componentCnt - 1`

따라서 최소 연산 = `cycleCnt + (componentCnt - 1)`

코드에서의 누적 `cnt`는 최종적으로 `cycleCnt + componentCnt`가 되고,
마지막에 `-1`을 해서 `cycleCnt + componentCnt - 1`을 출력한다.

---

## 🧩 Union-Find(DSU) 구성
### `find(x)`
- x의 대표(root)를 찾는다
- 경로 압축(Path Compression)으로 이후 탐색을 빠르게 한다

### `union(u, v)`
- 각자의 루트 `ru`, `rv`를 찾는다
- `ru == rv`면 이미 연결된 상태 → 이 간선은 사이클을 만든다
- 다르면 한쪽 루트를 다른 쪽에 붙여 집합을 합친다

---

## ⏱️ 복잡도
- `M`개의 union/find 수행
- 경로 압축을 쓰면 거의 상수 시간에 가깝게 동작

- 시간 복잡도: `O((N + M) α(N))` (α는 매우 느리게 증가하는 함수)
- 공간 복잡도: `O(N)` (parent/root 배열)

---

## 📝 구현 포인트(코드 기준)
- `root[i] = i` 로 초기화해 각 노드를 자기 집합으로 시작
- `find`에서 경로 압축을 적용해 성능 확보
- “사이클 간선”은 `union`에서 루트가 같을 때 바로 카운트
- “컴포넌트 수”는 마지막에 `root[i] == i`인 개수로 계산

---

