# 🧩 BOJ 1987 - 알파벳

- 🔗 문제 링크: https://www.acmicpc.net/problem/1987
- 🏷️ 분류: DFS / 백트래킹

---

## 📌 문제 요약

R×C 보드에 알파벳 대문자가 적혀 있다.  
(0,0)에서 시작해 상/하/좌/우로 이동하면서 **지나온 칸의 알파벳을 중복 없이** 방문할 때,  
**최대로 이동할 수 있는 칸 수(경로 길이)**를 구한다.

---

## 💡 풀이 아이디어

가능한 모든 경로를 탐색해야 하고, 이동 중 **같은 알파벳을 다시 밟을 수 없다**.  
따라서 **DFS + 백트래킹**으로 다음을 반복한다.

- 현재 칸의 알파벳을 방문 처리한다.
- 4방향으로 이동 가능한 칸을 찾는다.
- 이동 후 재귀 호출로 탐색을 이어간다.
- 탐색이 끝나고 돌아오면 방문 처리를 해제한다(백트래킹).
- 탐색 과정에서 최대 길이를 계속 갱신한다.

---

## ✅ 방문 체크(중복 알파벳 방지)

알파벳은 총 26개이므로 길이 26의 배열로 방문 여부를 관리한다.

- `cnt[ch] == 1` : 이미 방문한 알파벳
- `cnt[ch] == 0` : 아직 방문하지 않은 알파벳

보드의 문자를 `'A'~'Z'`에서 `0~25`로 변환해 저장해두면,  
`cnt[Map[x][y]]` 형태로 바로 방문 체크가 가능하다.

---

## 🔁 DFS / 백트래킹 로직

### 상태(재귀에서 들고 가는 값)

- `(x, y)` : 현재 위치
- `len` : 현재까지 이동한 칸 수
- `cnt[26]` : 알파벳 방문 여부 배열
- `max_len` : 최대 경로 길이(전역으로 갱신)

### 이동(4방향)

상/하/좌/우 4방향으로 다음 칸 `(nx, ny)`를 만든다.

### 다음 칸으로 이동 가능한 조건

- 보드 범위를 벗어나지 않는다.
- 다음 칸의 알파벳이 아직 방문되지 않았다.

조건을 만족하면:

1. 다음 알파벳 방문 처리
2. 재귀 호출로 `len + 1` 탐색
3. 돌아오면 방문 처리 해제(백트래킹)

---

## ⏱️ 복잡도

- 최대 경로 길이는 알파벳 개수 때문에 `26`을 넘지 못한다.
- 각 단계에서 최대 4방향으로 분기하므로,

- 시간 복잡도: `O(4^L)` (L ≤ 26)
- 공간 복잡도: `O(L)` (재귀 스택)

---

## 📝 개선 포인트(선택)

- 입력이 많을 때 `Scanner`는 느릴 수 있어 `BufferedReader` 사용이 더 안전하다.
- 방문 체크를 배열 대신 **비트마스크(int)**로 구현하면 더 빠르고 깔끔해진다.
