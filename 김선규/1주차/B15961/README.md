# 🍣 BOJ 15961 - 회전 초밥

- 🔗 문제 링크: https://www.acmicpc.net/problem/15961
- 🏷️ 분류: 슬라이딩 윈도우, 투 포인터, 빈도 배열(카운팅)

---

## 📌 문제 요약
원형으로 이어진 초밥 벨트에서 연속한 `k`개의 접시를 먹을 때,  
먹을 수 있는 **서로 다른 초밥 종류의 최대 개수**를 구한다.

추가 조건:
- 쿠폰 번호 `c`에 해당하는 초밥을 **무료로 1개 추가로 먹을 수 있음**
- 단, 이미 연속 `k`개 안에 `c`가 포함되어 있다면 종류 수는 그대로

입력:
- `N` : 접시 수(벨트 길이)
- `d` : 초밥 종류 수(번호 1~d)
- `k` : 연속해서 먹는 접시 수
- `c` : 쿠폰 초밥 번호

---

## 💡 풀이 아이디어
연속 `k`개 구간을 한 칸씩 밀어가며(슬라이딩 윈도우) **현재 구간의 초밥 종류 수**를 빠르게 갱신한다.

핵심:
- 현재 윈도우에 포함된 각 초밥 번호의 개수를 `chobob_cnt[]`에 저장
- 윈도우 내 서로 다른 종류 수를 `type_cnt`로 유지
- 매 윈도우마다 쿠폰 `c`가 포함됐는지 확인해 정답 후보 갱신

---

## ✅ 자료구조 / 상태 정의
- `belt[N]` : 벨트의 초밥 번호 저장
- `chobob_cnt[d+1]` : 각 초밥 번호의 현재 윈도우 내 개수
- `type_cnt` : 현재 윈도우에서 서로 다른 초밥 종류 개수
- 포인터:
  - `p1` : 윈도우에서 빠질 접시 인덱스
  - `p2` : 윈도우에 새로 들어올 접시 인덱스(원형 처리)

---

## 🪟 윈도우 초기화(첫 구간 만들기)
처음 `0 ~ k-1` 구간을 만들면서:

- 어떤 초밥 번호가 처음 등장하면 `type_cnt++`
- 개수는 `chobob_cnt[번호]++`

초기 정답은 쿠폰 포함 여부로 계산한다.

- 쿠폰 초밥 `c`가 윈도우에 없다면: `type_cnt + 1`
- 있다면: `type_cnt`

---

## 🔁 슬라이딩 윈도우 갱신
윈도우를 한 칸 오른쪽으로 이동할 때:

1) 왼쪽(p1) 제거
- `chobob_cnt[belt[p1]]--`
- 0이 되면 해당 종류가 윈도우에서 사라진 것 → `type_cnt--`

2) 오른쪽(p2) 추가 (원형 벨트)
- `p2++` 후 `p2==N`이면 `p2=0`
- 추가 전 0이면 새 종류 등장 → `type_cnt++`
- `chobob_cnt[belt[p2]]++`

3) 정답 갱신(쿠폰 고려)
- 윈도우에 쿠폰 초밥 `c`가 없으면 `type_cnt + 1`
- 있으면 `type_cnt`

이 과정을 `N`번 수행하면 모든 연속 구간을 한 번씩 확인한 것과 같다.

---

## 🎟️ 쿠폰 처리 규칙
매 윈도우마다:

- `chobob_cnt[c] == 0` → 쿠폰으로 새로운 종류 추가 가능 → `type_cnt + 1`
- `chobob_cnt[c] > 0` → 이미 먹는 중 → `type_cnt`

---

## ⏱️ 복잡도
- 각 이동에서 하는 작업은 O(1) (카운팅/포인터 갱신)
- 윈도우 이동 횟수는 N번

- 시간 복잡도: `O(N)`
- 공간 복잡도: `O(N + d)` (belt 배열 + 카운팅 배열)

---

## 📝 구현 포인트(코드 기준)
- `chobob_cnt`는 초밥 번호가 `1..d`라서 크기를 `d+1`로 둔다.
- 원형 벨트는 `p2 == N`이면 `p2 = 0`으로 처리한다.
- 매 단계에서 `type_cnt`를 재계산하지 않고 “증가/감소”만 하므로 빠르다.

---
