# 🧪 BOJ 14502 - 연구소

- 🔗 문제 링크: https://www.acmicpc.net/problem/14502
- 🏷️ 분류: 완전탐색(조합) + BFS, 백트래킹

---

## 📌 문제 요약
N×M 연구소 지도에서

- `0` : 빈 칸
- `1` : 벽
- `2` : 바이러스

가 주어진다.  
빈 칸 중 **3칸을 골라 벽을 세운 뒤**, 바이러스를 상/하/좌/우로 확산시켰을 때  
**안전 영역(0의 개수)을 최대화**하는 값을 구한다.

---

## 💡 풀이 아이디어
핵심은 두 단계의 결합이다.

1. 🧱 **벽 3개 세우기**: 빈 칸(0) 중 3개를 선택하는 모든 경우를 탐색  
   - 백트래킹으로 벽을 하나씩 세우며 `cnt == 3`이 되면 확산 시뮬레이션 수행

2. 🦠 **바이러스 확산**: 벽을 세운 상태에서 바이러스를 BFS로 확산  
   - 확산이 끝난 뒤 남아있는 `0`의 개수를 세어서 안전 영역 크기 계산  
   - 최대값을 갱신

---

## 🧱 벽 세우기(백트래킹)
### 함수: `wall(int cnt)`
- `cnt` : 지금까지 세운 벽 개수
- 종료 조건: `cnt == 3`이면 `virus()` 호출 후 리턴

### 진행 방식
- 맵 전체를 돌며 `0(빈 칸)`을 찾으면 벽을 세운다(`1`로 변경)
- 재귀 호출로 다음 벽을 세운다
- 돌아오면 원상 복구(`0`으로 변경) → 백트래킹

---

## 🦠 바이러스 확산(BFS)
### 함수: `virus()`
벽을 세운 상태의 `Map`을 기반으로 **복사본 `tmpMap`**에서만 확산을 수행한다.

### 처리 흐름
1. `tmpMap`에 `Map`을 복사
2. 초기 바이러스(값이 2인 칸)를 전부 큐에 넣고 BFS 시작
3. 큐에서 하나씩 꺼내 4방향으로 퍼뜨린다
   - 범위 안인지
   - `tmpMap[nx][ny] == 0`인지(빈 칸만 확산)
   - 방문 여부 체크(`visited`)로 중복 처리 방지
4. BFS 종료 후 `tmpMap`에서 `0`의 개수를 세어 `safe_cnt` 계산
5. `max_safe_cnt = max(max_safe_cnt, safe_cnt)`로 최대 안전 영역 갱신

---

## ✅ 구현 포인트(코드 기준)
- 📌 전역 변수로 `N, M, Map, max_safe_cnt`를 관리해 함수 간 공유
- 📌 확산은 반드시 원본 Map이 아닌 `tmpMap`에서 수행 → 다음 케이스 탐색에 영향 없음
- 📌 입력은 `BufferedReader + StringTokenizer`로 처리(Scanner보다 빠름)

---

## ⏱️ 복잡도
- 벽 3개를 세우는 경우의 수: 빈 칸을 E개라 하면 대략 `O(E^3)`
- 각 경우마다 BFS 확산: `O(N*M)`

따라서 전체는 대략:
- 시간 복잡도: `O(E^3 * N*M)` (문제 제한에서 충분히 통과 가능)
- 공간 복잡도: `O(N*M)` (`tmpMap`, `visited`, BFS 큐)

---

## 📝 개선 아이디어(선택)
- `visited` 없이도 `tmpMap[nx][ny]`를 `2`로 바꾸는 순간 방문 처리 효과가 있으므로,
  `visited`를 제거해도 동작한다(코드 간소화 가능).
- 현재 `wall()`은 매 재귀마다 (0,0)부터 전체 탐색을 다시 시작하므로
  중복 조합이 많이 생긴다.
  - 빈 칸 리스트를 미리 저장하고, 인덱스를 넘기면서 조합을 만들면 탐색량을 더 줄일 수 있다.

---
