# 🔢 BOJ 1082 - 방 번호

- 🔗 문제 링크: https://www.acmicpc.net/problem/1082
- 🏷️ 분류: 그리디, 자리수 최적화

---

## 📌 문제 요약
0 ~ N-1 숫자 각각의 가격이 주어지고, 예산 `M` 안에서 숫자를 사서 **가장 큰 수(문자열 기준, 자릿수 우선)** 를 만들어야 한다.

- 숫자는 여러 번 살 수 있음
- 결과는 “정수 크기”가 아니라 **자리수가 길수록 무조건 더 큼**
- 같은 자리수라면 **앞자리부터 큰 숫자**가 더 큼

---

## ❗ 시행착오 (백트래킹 → 시간초과/시간 과다)
처음엔 백트래킹으로 모든 조합을 만들려고 했는데 **시간초과**가 났다.  
백트래킹에 “이전 자리보다 같거나 작은 숫자부터 탐색” 같은 가지치기를 넣으니 풀리긴 했지만,
여전히 **실행 시간이 너무 오래** 걸렸다.

➡️ 그래서 완전탐색 대신, 아래 그리디 전략으로 바꿨다.

---

## 💡 풀이 아이디어 (그리디 2단계)
핵심은 “가장 큰 수”의 기준이 다음 우선순위를 가진다는 점이다.

1) **자릿수 최대화**
2) 자릿수가 같다면 **앞자리부터 최대화(사전순/내림차순)**

따라서 전략은 2단계로 나뉜다.

### 1) 예산으로 만들 수 있는 “최대 자릿수”를 먼저 만든다
- 첫 자리는 0이 올 수 있으므로 주의해야 한다.
- 하지만 이 코드에서는 “최대 자릿수”를 만들기 위해
  - 첫 자리에 들어갈 수 있는 최소 비용 숫자(0 제외) `minNum`을 확보하고
  - 남은 자리는 가장 싼 숫자(0 포함 가능)로 채운다

코드에서는:
- `minPrice` = 0을 제외한 숫자들 중 최소 가격
- `maxSize` 계산:
  - 우선 1자리는 만들고,
  - 남은 돈으로 “가장 싼 숫자”를 추가 구매해 자리수를 늘린다

### 2) 만든 자리수를 유지한 채, 앞자리부터 가능한 가장 큰 숫자로 “업그레이드”한다
이미 최소 비용 숫자들로 `maxSize`를 채운 상태에서,
각 자리 i에 대해:

- 현재 숫자 `boughtNum[i]`를 더 큰 숫자 `j`로 바꾸는 데 추가로 필요한 비용:
  - `price[j] - price[boughtNum[i]]`
- 이 추가 비용이 남은 예산 `M` 이하라면 교체 가능
- 앞자리부터 가능한 가장 큰 숫자로 바꾸면 전체 수가 최대가 된다

---

## ✅ 알고리즘 흐름 정리
1. 입력에서 가격 배열 `price[]` 저장
2. `0`을 제외한 최소 가격 숫자(`minNum`, `minPrice`) 찾기
3. 최대 자릿수 `maxSize` 계산
4. `maxSize`만큼 가장 싼 숫자로 채워 초기 숫자 구성
5. i=0부터 순서대로, 가능한 가장 큰 숫자로 교체(남은 예산 내)
6. 최종 배열을 이어붙여 출력

---

## 🧠 구현 포인트(코드 기준)
- 초기 채우기에서 `price[0]`과 `minPrice`를 비교해 더 싼 쪽으로 채움:
  - `boughtNum[i] = (price[0] < minPrice) ? 0 : minNum`
- 교체는 **앞자리부터**, **큰 숫자부터(N-1 down)** 탐색:
  - 가장 큰 숫자로 한 번 교체되면 그 자리는 더 볼 필요 없음

---

## ⏱️ 복잡도
- 자리수 길이 = `maxSize` (예산에 의해 결정)
- 각 자리마다 최대 N번(큰 숫자부터) 확인

- 시간 복잡도: `O(maxSize * N)`
- 공간 복잡도: `O(maxSize)`

---

## 📝 왜 이 방법이 통하는가?
- “가장 큰 수”는 **자릿수**가 최우선이므로,
  먼저 자릿수를 최대화하는 게 항상 이득이다.
- 자릿수가 고정되면, 가장 왼쪽 자리부터 크게 만드는 것이
  전체 수를 최대로 만든다(사전순 최대화).

---
