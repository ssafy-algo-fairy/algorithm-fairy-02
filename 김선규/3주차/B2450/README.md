# 🔁 BOJ 2450 - 모양 정돈

- 🔗 문제 링크: https://www.acmicpc.net/problem/2450
- 🏷️ 분류: 완전탐색(순열 3!), 카운팅/그리디(교환 + 3-cycle), 구현

---

## 📌 문제 요약
길이 `N`의 배열에 `1, 2, 3`만 존재한다.  
배열을 “같은 숫자끼리 연속하게” 정렬하되, 숫자 블록의 순서(예: `1→2→3` 또는 `2→1→3` 등)는 자유다.

한 번의 연산은 **서로 다른 두 위치의 값을 swap(자리 바꾸기)** 하는 것이라고 할 때,  
목표 형태(세 블록이 연속)로 만들기 위한 **최소 swap 횟수**를 구한다.

---

## 💡 핵심 아이디어
최종 목표 배열은 항상 다음 형태 중 하나다.

- `A...A B...B C...C` (A,B,C는 {1,2,3}의 순열)

즉, 가능한 목표는 `3! = 6`가지 뿐이라서  
각 순열(블록 순서)을 전부 시도해 최소 swap을 계산하면 된다.

각 목표에 대해 “현재 자리의 숫자”와 “목표 자리의 숫자”가 다른 경우를 누적해  
`diff[x][y] = (원래 x였던 자리를 y로 바꿔야 하는 개수)`를 만든다.

---

## ✅ diff 행렬 의미
`diff[a][b]` : 원래 숫자 `a`가 들어있는 원소가  
목표 배열에서는 숫자 `b`가 있어야 하는 구간에 들어간 개수

예)
- `diff[1][2]`가 5라면  
  “원래 1인 원소 5개가 목표에서는 2자리로 가야 한다”는 뜻

코드는 목표 순열을 만들면서 구간 단위로 비교해 `diff`를 누적한다.

---

## 🔧 최소 swap 계산 로직 (핵심)
질문에서 정리한 포인트 그대로:

> 최소 swap을 만들려면  
> 1↔2, 1↔3, 2↔3 **서로 원위치로 돌아가는 쌍을 최대한 많이 직접 swap**하고,  
> 남는 것은 1→2→3 또는 1→3→2 형태의 **3개 로테이션(cycle)** 이므로  
> **2번 swap으로 처리**해야 한다.

### 1) 쌍으로 바로 교환 가능한 것부터 최대화
서로 바꿔주면 바로 해결되는 쌍:

- `1 ↔ 2` : `min(diff[1][2], diff[2][1])`
- `1 ↔ 3` : `min(diff[1][3], diff[3][1])`
- `2 ↔ 3` : `min(diff[2][3], diff[3][2])`

각 쌍 교환은 swap 1번으로 2개의 잘못된 배치를 동시에 해결한다.

코드에서:
- `n12, n13, n23`로 각각 계산하고,
- 해당만큼 diff를 줄인다.

### 2) 남는 것은 3-cycle (로테이션)
쌍교환을 최대한 하고 나면 남는 오차는 항상 3-cycle로만 남는다.

대표적으로 두 종류:
- `1 → 2 → 3 → 1` 형태 (코드에서 `n123`)
- `1 → 3 → 2 → 1` 형태 (코드에서 `n132`)

3-cycle 하나를 해결하려면 최소 swap 2번이 필요하다.
따라서 추가 비용은:

- `2 * (n123 + n132)`

최종 swap 수:
- `n12 + n13 + n23 + 2*(n123 + n132)`

---

## 🔁 목표 순열(블록 순서) 탐색
목표 블록 순서가 6가지이므로 재귀로 `{1,2,3}`의 순열을 만든다.

- `selected[i]`로 숫자 사용 여부 체크
- 현재 선택한 숫자 `i`의 블록 길이는 `numCnt[i]`
- 현재 idx부터 `numCnt[i]` 길이만큼의 구간이 목표 숫자 `i`의 구간이 된다
- 그 구간에서 원래 값이 `i`가 아니면 `diff[원래값][i]++`

순열 하나가 완성되면(즉 idx == N),
위의 “쌍교환 최대화 + 3-cycle 처리”로 swap 최소값을 계산해 `minChange`를 갱신한다.

---

## ⏱️ 복잡도
- 목표 순열 6가지
- 각 순열 평가 시 배열 구간 비교는 총 N번 수준
- 추가 계산은 상수

- 시간 복잡도: `O(6N)` ≈ `O(N)`
- 공간 복잡도: `O(1)` (diff 4x4, 카운트 배열 등)

---

## 📝 구현 포인트(코드 기준)
- `numCnt[1..3]`로 각 숫자의 개수를 세어 블록 길이를 바로 결정
- `diff`는 상태 전달이 필요하므로 `copy()`로 2차원 배열 복사해서 재귀 사용
- leaf(순열 완성)에서:
  - 쌍 교환 가능한 만큼 먼저 처리
  - 남는 로테이션은 swap 2번씩 필요하다는 규칙으로 정답 계산

---