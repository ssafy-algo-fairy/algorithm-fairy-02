# 🌳 BOJ 14438 - 수열과 쿼리 17

- 🔗 문제 링크: https://www.acmicpc.net/problem/14438
- 🏷️ 분류: 세그먼트 트리(Segment Tree), 구간 최솟값(RMQ), 점 업데이트

---

## 📌 문제 요약
길이 `N`의 수열이 주어지고, `M`개의 쿼리를 처리한다.

쿼리 종류:
- `1 i v` : `A[i]`를 `v`로 변경 (점 업데이트)
- `2 l r` : 구간 `[l, r]`의 **최솟값** 출력 (구간 질의)

---

## 💡 풀이 아이디어
업데이트와 구간 최솟값 질의가 섞여 나오기 때문에,
매 쿼리마다 배열을 직접 갱신하고 구간을 선형 탐색하면 느리다.

➡️ **세그먼트 트리**를 사용하면
- 점 업데이트: `O(log N)`
- 구간 최솟값 질의: `O(log N)`
로 빠르게 처리할 수 있다.

---

## ✅ 세그먼트 트리 정의
- 트리의 각 노드는 특정 구간 `[start, end]`를 담당한다.
- `tree[node]`에는 그 구간의 **최솟값**을 저장한다.

### 트리 크기
- `treeSize`를 `N` 이상인 2의 거듭제곱으로 맞춘 뒤
- 배열 크기를 `treeSize * 2`로 잡는다.

---

## 🧱 트리 생성: `makeTree(start, end, node)`
- 리프 노드(`start == end`)는 `numArr[start]` 저장
- 내부 노드는 좌/우 자식의 최솟값을 저장

- `tree[node] = min(leftChild, rightChild)`

---

## 🔧 점 업데이트: `updateTree(start, end, node)`
쿼리 `1 i v`에 대해
- 전역 변수 `idx`(0-index), `num`(새 값)을 설정하고 호출

업데이트 흐름:
- 리프까지 내려가서 값을 `num`으로 바꿈
- 돌아오면서 각 구간의 최솟값을 다시 갱신

- 시간: `O(log N)`

---

## 🔍 구간 최솟값: `getMin(start, end, node)`
쿼리 `2 l r`에 대해
- 전역 변수 `left`, `right`를 설정하고 호출

구간 처리 케이스:
1) 현재 구간이 질의 구간과 완전히 겹치지 않음  
- `Integer.MAX_VALUE` 반환 (min에 영향 없게)

2) 현재 구간이 질의 구간에 완전히 포함됨  
- `tree[node]` 반환

3) 부분 겹침  
- 좌/우로 내려가서 min을 합침

- 시간: `O(log N)`

---

## ⏱️ 복잡도
- 트리 생성: `O(N)`
- 점 업데이트(쿼리 1): `O(log N)`
- 구간 최솟값(쿼리 2): `O(log N)`

전체: `O((N + M) log N)` 수준

공간:
- `tree` 배열: `O(2 * treeSize)` → `O(N)`급

---

## 📝 구현 포인트(코드 기준)
- 입력은 1-index로 주어지므로 내부 배열 처리를 위해 `-1`로 0-index로 변환
- 범위 밖 반환값은 `Integer.MAX_VALUE`로 설정해 `min()` 결합에 안전하게 처리
- 재귀 형태로 구현해 트리 생성/업데이트/질의를 모두 일관된 방식으로 처리

---
