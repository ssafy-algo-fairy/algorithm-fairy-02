# 👨‍👩‍👧‍👦 BOJ 21276 - 계보 복원가 호석

- 🔗 문제 링크: https://www.acmicpc.net/problem/21276
- 🏷️ 분류: 그래프(위상정렬 아이디어), 진입차수(in-degree) 관리, 구현

---

## 📌 문제 요약
N명의 이름과, M개의 (자식, 부모) 관계가 주어진다.  
이 관계는 “부모 → 자식” 방향의 DAG(사이클 없음) 형태로 주어진다고 볼 수 있다.

출력해야 할 것:
1) **시조(조상이 없는 사람)** 의 수와 이름 목록
2) 모든 사람에 대해
   - 그 사람의 **직계 자식(바로 아래 세대)** 수와 이름 목록

---

## 💡 풀이 아이디어
주어진 관계는 “부모 → 자식” 방향의 그래프이며,
어떤 사람의 부모 수(진입차수)를 알고 있으면 다음을 할 수 있다.

- 진입차수가 0인 사람 = 조상이 없음 → 시조
- 어떤 부모의 자식 후보들 중에서,
  진입차수가 0이 되는 순간(모든 부모 처리가 끝난 순간)의 자식만
  “직계 자식”으로 확정 가능

즉, 위상정렬처럼 **진입차수를 줄여가며 직계 자식을 확정**하는 방식이다.

---

## ✅ 자료구조
- `nameList` : 전체 이름 목록
- `sToNum (HashMap<String, Integer>)` : 이름 → 인덱스(ID) 매핑
- `edge` : `edge[parentId]` = (현재는) parent의 자식 후보 목록(String)
- `outCnt (HashMap<String, Integer>)` : 사람별 부모 수(진입차수)

추가로:
- `anc` : 시조 목록(진입차수 0인 사람들)

---

## 1) 🌱 시조(조상 없는 사람) 찾기
입력 관계를 읽을 때:
- `edge[parent].add(child)`
- `outCnt[child]++` (자식의 부모 수 증가)

모든 관계 입력 후:
- `outCnt[name] == 0` 인 사람들을 `anc`에 모으면 시조가 된다.
- 시조는 사전순 정렬 후 출력

---

## 2) 👶 직계 자식 찾기: `findC(parent)`
핵심은 “parent의 자식 후보들 중에서, 이제 부모가 더 이상 남지 않은 사람”만
직계 자식으로 확정하는 것이다.

`findC(parent)`에서 하는 일:
1) parent의 자식 후보 `edge[parent]`를 순회
2) 각 자식 `child`에 대해 `outCnt[child]--`
   - parent가 처리되었으니, child의 남은 부모 수를 1 줄임
3) `outCnt[child] == 0`이 되는 순간,
   - child는 **직계 자식**이 될 조건을 만족 → `newList`에 추가
4) parent의 `edge[parent]`를 `newList`로 교체
   - (부모 기준으로 “직계 자식만 남기기”)
5) 새로 확정된 직계 자식들에 대해 재귀적으로 `findC(child)` 수행

이 과정을 시조들부터 시작하면,
전체 계보가 “직계 자식” 형태로 정리된다.

---

## 🖨️ 출력 형식 처리
- 시조 목록 출력 후,
- 전체 사람을 사전순으로 정렬하여 각 사람에 대해 출력:
  - `이름 직계자식수 직계자식이름들...`
- 직계자식 이름들도 사전순으로 정렬하여 출력

---

## ⏱️ 복잡도
- 관계 입력 및 기본 구성: `O(N + M)`
- `findC` 과정에서 각 간선은 진입차수를 한 번 감소시키는 데 사용되므로 대략 `O(N + M)`
- 정렬 비용:
  - 이름 정렬 `O(N log N)`
  - 자식 리스트 정렬 합 `O(M log M)` 수준(전체 합 기준)

---

## 📝 구현 포인트(코드 기준)
- 이름을 인덱스로 매핑해 리스트 기반으로 관리(`sToNum`)
- `outCnt`를 진입차수처럼 사용해 “직계 자식 확정” 시점을 판별
- `edge[parent]`를 “자식 후보”에서 “직계 자식”으로 바꾸기 위해 `edge.set(parentId, newList)` 사용
- 시조(anc)부터 `findC`를 수행해야 전체 트리가 올바르게 확정됨

---