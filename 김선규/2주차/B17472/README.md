# 🏝️ BOJ 17472 - 다리 만들기 2

- 🔗 문제 링크: https://www.acmicpc.net/problem/17472
- 🏷️ 분류: BFS(섬 라벨링), 간선 생성(직선 탐색), MST(Kruskal), Union-Find(DSU)

---

## 📌 문제 요약
0(바다), 1(땅)으로 이루어진 N×M 격자에서 여러 섬이 존재한다.  
섬과 섬을 **직선 다리**로 연결해 모든 섬을 하나로 만들 때, 필요한 다리 길이 합의 최솟값을 구한다.

다리 규칙:
- 상/하/좌/우 방향으로만 뻗을 수 있음(대각선 X)
- 다리는 바다(0) 위로만 놓임
- 다리 길이는 **최소 2 이상**이어야 함
- 모든 섬을 연결할 수 없으면 `-1`

---

## 💡 풀이 흐름
전체 과정은 크게 3단계다.

1) 🧭 BFS로 섬 찾기(섬을 분리해서 저장)  
2) 🌉 섬 사이에 만들 수 있는 다리 후보(간선) 구하기  
3) 🔗 간선들로 MST(최소 스패닝 트리) 구성 → 최소 길이 합 계산

---

## 1) 🧭 BFS로 섬 분리 (섬 목록 만들기)
격자를 순회하다가,
- `Map[i][j] == 1` 이고
- 아직 방문하지 않았다면

그 지점에서 BFS를 돌려 **연결된 모든 땅을 하나의 섬(Island)** 으로 묶는다.

코드 구조:
- `visited[][]`로 방문 체크
- `Island.land`에 해당 섬의 모든 좌표(Point)를 저장
- 섬을 찾을 때마다 `islandNum++`

결과:
- `islandList`에 섬들이 저장되고,
- 섬 개수 `islandNum`이 결정된다.

---

## 2) 🌉 다리 후보(간선) 생성
각 섬에 대해, 그 섬에 속한 **모든 땅 좌표**에서 4방향으로 직선 탐색을 수행한다.

직선 탐색 방식:
- 현재 땅에서 한 칸씩 전진하며 바다를 지나간다(길이 len 증가)
- 다음 조건을 만나면 종료:
  - 격자 밖 → 중단
  - 땅(다른 섬)을 만남 → 다리 가능성 판단

다리 성립 조건:
- 다른 섬의 땅을 만났을 때 `len >= 2` 이어야 함 (길이 최소 2)

코드에서는:
- `connected[i][j]`에 i섬↔j섬을 잇는 다리의 최소 길이를 기록한다.
- 여러 위치에서 같은 두 섬을 잇는 다리가 나올 수 있으므로
  - `connected[i][j] = min(existing, len)` 형태로 최솟값을 유지한다.

---

## 3) 🔗 MST 구성 (Kruskal + Union-Find)
`connected[][]`에 기록된 다리들 중 유효한 것들을 `edgeList`로 옮긴다.

- `edgeList` 원소: `(섬 i, 섬 j, 다리 길이 len)`
- 길이 오름차순 정렬 후 Kruskal 수행

Kruskal:
- 간선을 짧은 순으로 보며
- 서로 다른 집합(루트)이면 연결(union)하고 `lenSum += len`
- 같은 집합이면 스킵(사이클 방지)

Union-Find:
- `root[]`로 부모 관리
- `find()`는 경로 압축 적용

---

## ✅ 연결 불가능 판정
Kruskal 이후에도 섬들이 모두 하나로 묶이지 않을 수 있다.

- `root[i] == i`인 루트의 개수를 세어서
  - 2개 이상이면 모든 섬 연결 불가 → `-1`
  - 1개면 연결 완료 → `lenSum` 출력

---

## ⏱️ 복잡도 (현재 코드 기준)
- 섬 찾기(BFS): `O(N*M)`
- 다리 후보 탐색:
  - 각 섬의 모든 땅에서 4방향 직선 탐색 + 목적지 섬 찾는 과정에서 섬 전체를 훑는 형태라
  - 구현상 비용이 커질 수 있음 (작은 범위에선 통과 가능)
- MST(Kruskal): `O(E log E)` (E는 후보 다리 수)

---

## 📝 구현 포인트 / 주의사항
- 다리 길이는 “바다 칸 수”이며 **2 이상만 인정**
- 직선으로만 다리 생성(중간에 땅 만나면 종료)
- 동일한 두 섬 사이 다리가 여러 개면 **가장 짧은 것만 유지**
- MST 후에도 연결이 안 되면 `-1` 처리

---
