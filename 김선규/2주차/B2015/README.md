# ➕ BOJ 2015 - 수들의 합 4

- 🔗 문제 링크: https://www.acmicpc.net/problem/2015
- 🏷️ 분류: 누적합(Prefix Sum), 해시맵(HashMap), 카운팅

---

## 📌 문제 요약
길이 `N`의 수열이 주어질 때, 합이 `K`가 되는 **연속 부분 구간(subarray)** 의 개수를 구한다.

출력은 경우의 수가 커질 수 있으므로 정답은 큰 수가 될 수 있다.

---

## ❗ 시행착오 (시간 초과)
처음에는 누적합을 구한 뒤,

- 모든 `(i, j)`에 대해 `i~j` 부분합을 계산

하는 방식으로 접근했는데, 이는 `O(N^2)`라서 **시간 초과**가 났다.

➡️ 그래서 관점을 바꿔,
“현재 누적합에서 `K`를 뺀 값이 과거에 몇 번 등장했는지”를 세는 방식으로 해결했다.

---

## 💡 풀이 아이디어
누적합을 `S[i] = A[0] + ... + A[i]` 라고 하면,

구간 `(l..r)`의 합은

- `S[r] - S[l-1]`

이다.

구간 합이 `K`가 되려면:

- `S[r] - S[l-1] = K`
- `S[l-1] = S[r] - K`

즉, **현재 r에서의 누적합 `S[r]`가 주어졌을 때**
`S[r] - K` 값이 과거에 몇 번 등장했는지를 더해주면,
`r`을 끝으로 하는 합 K 구간의 개수를 알 수 있다.

이를 위해 `HashMap<누적합 값, 등장 횟수>`를 유지한다.

---

## ✅ 알고리즘 흐름
1. 입력을 읽으며 누적합 배열 `sumArr[i]`를 만든다.
2. 해시맵 `map`에 누적합 값의 등장 횟수를 저장한다.
3. 각 i에 대해:
   - `need = sumArr[i] - K`
   - `need`가 map에 몇 번 등장했는지 `ansCnt`에 더한다.
   - `sumArr[i]`를 map에 1 증가시켜 기록한다.
4. 최종 `ansCnt` 출력

---

## 🗂️ 자료구조
- `sumArr[i]` : i까지 누적합 (long)
- `map: HashMap<Long, Integer>`
  - key: 누적합 값
  - value: 그 누적합 값이 지금까지 등장한 횟수
- `ansCnt` : 정답(부분 구간 개수) → long

---

## ⭐ 중요한 초기값: `map.put(0L, 1)`
누적합이 정확히 `K`가 되는 구간이 **0번 인덱스부터 시작하는 경우**를 처리하기 위해
“시작 전에 누적합 0이 한 번 있었다”고 세팅한다.

예)
- `S[i] == K` 이면 `need = 0`
- map에 0이 1번 있으므로 정답이 올바르게 1 증가한다.

---

## ⏱️ 복잡도
- 각 원소마다 HashMap 조회/갱신을 1번씩 수행

- 시간 복잡도: `O(N)` (평균)
- 공간 복잡도: `O(N)` (누적합 종류 수만큼 map이 커질 수 있음)

---

## 📝 구현 포인트(코드 기준)
- 누적합은 합이 커질 수 있어 `long` 사용 (`sumArr`, map key)
- 정답 개수도 커질 수 있어 `long ansCnt` 사용
- `map.getOrDefault(key, 0)`로 안전하게 카운팅

---
