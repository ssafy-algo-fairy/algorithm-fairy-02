# 🌟 BOJ 23326 - 홍익 투어리스트

- 🔗 문제 링크: https://www.acmicpc.net/problem/23326
- 🏷️ 분류: 자료구조, TreeSet(균형 이진 탐색 트리), 시뮬레이션

---

## 📌 문제 요약
원형으로 이어진 `N`개의 구역이 있고, 각 구역은 **명소(1)** 또는 **일반(0)** 이다.  
도현이는 현재 위치에서 다음 쿼리를 처리한다.

- `1 i` : i번 구역의 명소 여부를 토글(명소면 해제, 아니면 지정)
- `2 x` : 현재 위치를 시계 방향으로 x칸 이동
- `3` : 현재 위치에서 시계 방향으로 이동했을 때 **가장 가까운 명소까지 최소 이동 칸 수** 출력  
  - 명소가 하나도 없으면 `-1`

---

## 💡 풀이 아이디어
핵심은 쿼리 `3`을 빠르게 처리하는 것이다.

- 단순히 매번 한 바퀴를 탐색하면 `O(N)`이 걸려서 쿼리가 많을 때 비효율적이다.
- 명소의 위치(인덱스)만 정렬된 상태로 관리하면,
  현재 위치 `cur` 이상에서 가장 가까운 명소를 **이진 탐색으로 바로 찾을 수 있다.**

이를 위해 Java의 `TreeSet`을 사용한다.

---

## ✅ TreeSet을 사용한 이유 (개인 메모)
이번 문제는 **TreeSet을 몰라서 굉장히 어려웠다.**  
쿼리 `3`을 빠르게 처리하려면 “현재 위치 기준으로 다음 명소를 빠르게 찾는” 기능이 필요했고,  
TreeSet의 `ceiling()`, `first()` 같은 메서드를 찾아보고 나서야 해결 방법이 보였다.

- `TreeSet`은 원소를 **정렬된 상태로 유지**하며,
- `ceiling(x)`로 `x 이상인 최소 원소`를 `O(log N)`에 찾을 수 있어 이 문제에 딱 맞았다.

---

## ✅ 자료구조 / 상태 정의
- `cur` : 도현이의 현재 위치 (0-index)
- `ts` : 명소인 구역의 인덱스를 담는 `TreeSet<Integer>`
  - 항상 오름차순으로 유지됨

초기 입력에서 명소(값 1)인 인덱스만 `ts`에 저장한다.

---

## 🔁 쿼리 처리 방법
### 1) `1 i` : 명소 토글
- `i`는 입력이 1-index이므로 `-1` 해서 0-index로 맞춘다.
- 이미 존재하면 제거, 없으면 추가

- 시간: `O(log N)`

---

### 2) `2 x` : 이동
원형이므로 모듈러로 처리한다.

- `cur = (cur + x) % N`
- 시간: `O(1)`

---

### 3) `3` : 가장 가까운 명소까지 거리
명소가 없다면 `-1`.

명소가 있다면, 두 가지 케이스 중 하나다.

- **현재 위치 `cur` 이상에서 명소가 존재**  
  - `ts.ceiling(cur)`이 null이 아님  
  - 거리 = `ts.ceiling(cur) - cur`

- **`cur` 이상에 명소가 없음(끝까지 가도 없음)**  
  - 한 바퀴 돌아야 함  
  - 거리 = `(N - cur) + ts.first()`

- 시간: `O(log N)` (`ceiling`, `first`)

---

## 🧠 핵심 포인트
- 명소 위치를 `TreeSet`으로 관리하면,
  “현재 위치 기준 다음 명소”를 매번 `O(log N)`에 찾을 수 있다.
- 원형 처리만 주의하면 된다.
  - `ceiling(cur)`이 없으면 `first()`로 wrap-around

---

## ⏱️ 복잡도
- `1 i` : `O(log N)`
- `2 x` : `O(1)`
- `3`   : `O(log N)`

전체 시간: `O(Q log N)` 수준으로 처리 가능  
공간: `O(N)` (최대 명소가 N개일 수 있음)

---
