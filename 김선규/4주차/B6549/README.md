# 📊 BOJ 6549 - 히스토그램에서 가장 큰 직사각형

- 🔗 문제 링크: https://www.acmicpc.net/problem/6549
- 🏷️ 분류: 스택/모노톤 자료구조 아이디어, 구현

---

## 📌 문제 요약
막대가 `N`개인 히스토그램이 주어진다.  
각 막대의 높이가 주어졌을 때, 히스토그램 내부에서 만들 수 있는 **가장 큰 직사각형의 넓이**를 구한다.

- 직사각형은 연속한 막대 구간을 선택해야 함
- 넓이 = (구간 길이) × (구간 내 최소 높이)

입력은 여러 테스트 케이스이며, `N=0`이면 종료한다.

---

## 💡 풀이 아이디어 (단조 구조의 원리)
가장 넓은 직사각형은 어떤 막대 `h`를 “최소 높이”로 하는 구간에서 결정된다.

왼쪽에서 오른쪽으로 진행하면서,
- 현재 높이 `h`보다 **큰 높이들**은 더 이상 오른쪽으로 확장할 수 없게 된다.
  - (현재 막대가 더 낮아서, 큰 높이를 최소 높이로 유지할 수 없음)

따라서 “지금 막대가 등장하는 순간, 이전의 더 큰 높이 후보들의 최대 넓이”를 확정하고 계산한다.

코드는 이를 `Height(h, n)` 형태로 관리하며:
- `h`: 높이
- `n`: 이 높이가 **확장 가능한 가장 왼쪽 시작 인덱스**

---

## ✅ 자료구조 / 상태
### `Height(h, n)`
- `h`: 높이 (long)
- `n`: 이 높이가 유효한 시작 인덱스(왼쪽 경계)

### `heightQ`
- `PriorityQueue<Height>`를 사용하며, 코드에서는 `h` 내림차순(큰 높이가 먼저)으로 poll되도록 설정되어 있다.

> 일반적인 정석 풀이는 “모노톤 스택(오름차순)”을 쓰지만,  
> 이 코드는 “현재 높이보다 큰 후보들을 제거하며 넓이 확정”이라는 동일한 핵심을
> PQ를 이용해 구현한 형태다.

---

## 🔁 처리 로직 (왼→오 진행)
각 막대 인덱스를 `i`, 현재 높이를 `h`라고 할 때:

1) `lastIdx = i`로 시작  
2) 큐의 top(가장 큰 높이) `maxH`가 현재 높이 `h` 이상이면:
   - `maxH`는 더 이상 오른쪽으로 확장할 수 없으므로 넓이를 확정:
     - 넓이 = `(i - maxH.n) * maxH.h`
   - `lastIdx`를 `maxH.n`으로 갱신  
     - (현재 높이 `h`는 더 왼쪽까지 확장 가능해짐)
   - 큐에서 제거
3) 더 이상 `maxH.h >= h`가 아니면 중단
4) 현재 높이 `h`를 `(h, lastIdx)`로 큐에 삽입

이렇게 하면 “현재 높이 h”는
- 자신보다 큰 높이들이 사라진 자리까지 왼쪽으로 확장 가능한 시작점을 가져가게 된다.

---

## 🧾 마지막 정리(끝까지 확장되는 후보 처리)
모든 막대를 처리한 뒤에도 큐에 남아있는 높이들은
끝(`N`)까지 확장 가능한 후보들이다.

따라서 남은 모든 `Height(maxH)`에 대해:
- 넓이 = `(N - maxH.n) * maxH.h`
로 최댓값을 갱신한다.

---

## ⏱️ 복잡도
- 각 막대는 큐에 1번 들어가고 1번 나올 수 있다.
- PQ 연산이 `O(log N)`이므로:

- 시간 복잡도: `O(N log N)` (테스트케이스당)
- 공간 복잡도: `O(N)`

> 참고: 모노톤 스택을 사용하면 `O(N)`으로도 풀 수 있는 문제다.

---

## 📝 구현 포인트(코드 기준)
- 넓이가 커질 수 있으므로 `long` 사용 (`h`, `maxVal`)
- 입력이 여러 케이스이므로 `N==0`일 때 종료
- 막대 처리 중 “더 큰 높이 후보의 종료 시점(현재 i)”에서 넓이를 확정한다는 점이 핵심

---