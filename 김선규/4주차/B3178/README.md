# 🌲 BOJ 3178 - 코코스

- 🔗 문제 링크: https://www.acmicpc.net/problem/3178
- 🏷️ 분류: 트라이(Trie) 아이디어, 문자열 정렬 + LCP(공통 접두사 길이), 구현

---

## 📌 문제 요약
길이가 `2K`인 문자열이 `N`개 주어진다.  
각 문자열을 앞/뒤로 `K`씩 나눌 수 있고, 뒤쪽은 어떤 기준에서 “역방향”으로도 비교가 필요하다.

문제는 트라이(Trie) 관점에서 필요한 연산 수(또는 비용)를 계산하는 형태이며,
결국 핵심은 다음 두 부분을 각각 처리해 합치는 것이다.

- 앞쪽 길이 K 문자열들에 대한 트라이 비용
- 뒤쪽 길이 K 문자열들(역순 처리)에 대한 트라이 비용

---

## ❗ 시행착오
처음에는 실제로 트리를 만들고 노드를 추가/탐색하는 방식으로 구현했는데,
문자열 수가 많을 때 노드 생성/탐색 비용이 커져 **시간 초과**가 발생했다.

➡️ 이후 트라이를 공부하고,
트라이를 직접 만들지 않고도 비용을 계산할 수 있다는 점을 이용해 해결했다.

---

## 💡 풀이 아이디어 (정렬 + LCP로 Trie 비용 계산)
트라이에서 여러 문자열을 삽입할 때,
**새로 생성되는 노드 수**는 “기존에 존재하는 공통 접두사(prefix)를 제외한 나머지”와 관련이 있다.

정렬된 문자열들을 인접하게 놓으면,
트라이에서 공유되는 접두사는 결국 **인접 문자열 간의 공통 접두사 길이(LCP)** 로 계산할 수 있다.

따라서:
1) 문자열들을 정렬한다.
2) 인접한 두 문자열의 공통 접두사 길이를 구해 누적한다.
3) 전체 비용(총 문자 수)에서 “공유된 접두사만큼”을 빼는 방식으로 결과를 계산한다.

---

## ✅ 앞/뒤 분리 처리
각 입력 문자열 `s`(길이 2K)에 대해:

- `front = s[0..K-1]`
- `back = s[K..2K-1]`
- 뒤쪽은 비교 방향을 맞추기 위해 뒤집어서 저장:
  - `backRev = reverse(back)`

이후 두 리스트를 각각 독립적으로 처리한다.

- `front` 리스트 정렬 후 인접 LCP 합: `sumFront`
- `backRev` 리스트 정렬 후 인접 LCP 합: `sumBack`

---

## 🔎 LCP 계산 함수 `cmp(a, b)`
두 문자열 `a`, `b`(길이 K)에 대해
앞에서부터 같은 문자가 몇 개 연속되는지 세어 LCP 길이를 반환한다.

- 반환값 범위: `0..K`

---

## 🧾 최종 식 (코드 기준)
각 문자열은 앞 K + 뒤 K, 총 `2K` 글자를 가진다.  
N개이므로 전체 글자 수는 `2 * N * K`.

여기서 트라이에서 공유되는 부분을 LCP 합으로 빼는 방식으로 계산한다:

- 결과 = `2 * N * K - sumFront - sumBack`

코드에서는 이를 `trie()`에서 그대로 반환한다.

---

## ⏱️ 복잡도
- 문자열 분리/역순: `O(N*K)`
- 정렬:
  - `O(N log N)` (문자열 비교 비용 포함)
- 인접 LCP 합:
  - `O(N*K)` (최악)

전체적으로:
- 시간 복잡도: `O(N log N * K)` 수준
- 공간 복잡도: `O(N*K)` (문자열 저장)

---

## 📝 구현 포인트(내 풀이 요약)
- 트리를 직접 만들면 노드/메모리/탐색 비용으로 시간 초과 가능
- 트라이의 “공유 접두사” 성질을 이용해
  - 앞/뒤를 분리
  - 뒤는 reverse해서 동일한 방식으로 처리
  - 각각 정렬 후 인접 LCP 합을 더해
  - 최종 값을 빠르게 계산했다

---