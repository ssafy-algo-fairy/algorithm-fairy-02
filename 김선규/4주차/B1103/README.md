# 🎮 BOJ 1103 - 게임

- 🔗 문제 링크: https://www.acmicpc.net/problem/1103
- 🏷️ 분류: DFS + DP(메모이제이션), 사이클 탐지(무한 루프)

---

## 📌 문제 요약
N×M 보드에서 (0,0)에서 시작한다.

- 각 칸에는 `1~9` 숫자 또는 `H`(구멍)가 있다.
- 현재 칸의 숫자가 `k`라면 상/하/좌/우 중 한 방향으로 **k칸 이동**한다.
- 구멍(H)으로 가거나 보드 밖으로 나가면 게임 종료.

목표:
- 최대 몇 번 움직일 수 있는지 출력
- 단, **무한히 움직일 수 있으면 -1 출력** (사이클 존재)

---

## ❗ 시행착오
처음엔 단순 `visited`만 두고 DFS로 모든 경로를 탐색했는데,
같은 칸을 여러 경로에서 반복해서 방문하게 되어 **시간 초과**가 발생했다.

➡️ 해결:
- `dp[x][y]`에 “(x,y)에서 시작했을 때 최대로 갈 수 있는 이동 횟수”를 저장해
  **한 번 계산한 칸은 다시 계산하지 않도록** 했다. (메모이제이션)
- `visited`는 방문 체크가 아니라 **현재 DFS 경로 상에서의 재방문(사이클) 탐지용**으로 사용했다.

---

## 💡 풀이 아이디어
### 1) DP(메모이제이션)
- `dp[x][y]` = (x,y)에서 시작했을 때 가능한 최대 이동 횟수
- 이미 `dp[x][y]`가 계산되어 있으면 그대로 반환 → 중복 탐색 제거

### 2) 사이클(무한 루프) 탐지
- DFS 탐색 중 현재 재귀 스택에 포함된 칸을 `visited[x][y]=1`로 표시
- DFS 도중 다시 `visited[x][y]==1`인 칸에 들어오면,
  이는 **현재 경로에서 사이클 발생** → 무한 루프 가능 → `-1` 처리

---

## ✅ 상태 정의
- `Map[x][y]`
  - 숫자(1~9): 이동 거리
  - 0: 구멍(H)을 0으로 변환해서 저장
- `visited[x][y]`
  - 현재 DFS 경로(재귀 스택)에 포함된 칸인지 표시 (무한 루프 체크)
- `dp[x][y]`
  - 해당 칸에서 시작했을 때의 최대 이동 횟수
  - `-1`이면 무한 루프가 확정된 상태로 전파

---

## 🔁 DFS 전이(핵심 로직)
`dfs(x, y)`에서:

1) **사이클 체크**
- `visited[x][y] != 0`이면 현재 경로에서 재방문 → `dp[x][y] = -1`

2) **메모이제이션**
- `dp[x][y] != 0`이면 이미 계산됨 → `dp[x][y]` 반환

3) **4방향 이동**
- 현재 칸 숫자를 `k = Map[x][y]`라 할 때
  - 다음 위치: `(nx, ny) = (x + dx[i]*k, y + dy[i]*k)`
- 범위 밖 or 구멍(0)이면 이동 불가 → 해당 방향 스킵
- 이동 가능하면 `dfs(nx, ny)` 호출
  - 반환값이 `-1`이면 무한 루프이므로 즉시 `-1` 전파
  - 아니면 최대값 갱신

4) **복귀 시 visited 해제**
- `visited[x][y] = 0` (재귀 스택에서 빠져나옴)

5) 최종:
- `dp[x][y] = maxChild + 1`

---

## 🧠 최종 출력
- 시작점 `(0,0)`의 결과가 정답
- 코드에서는 `dfs(0,0,1)`을 호출한 뒤 `dp[0][0]`을 출력

> (참고) `turn` 인자는 실제로는 DP 계산에 필요하진 않고, 로직상 영향도 없다.
> 이 구현에서는 `dp` 값으로 이동 횟수를 계산하므로 turn 없이도 동일하게 동작한다.

---

## ⏱️ 복잡도
- 각 칸은 `dp` 덕분에 최대 한 번만 “완전 계산”된다.
- 각 칸에서 최대 4방향만 탐색

- 시간 복잡도: `O(N*M)`
- 공간 복잡도: `O(N*M)` (dp/visited)

---

## 📝 구현 포인트(요약)
- 시간 초과 방지: `dp`로 중복 DFS 제거
- 무한 루프 판정: `visited`를 “현재 경로” 체크로 사용
- `-1`을 만나면 바로 전파해 불필요한 계산을 줄임

---