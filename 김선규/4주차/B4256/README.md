# 🌳 BOJ 4256 - 트리

- 🔗 문제 링크: https://www.acmicpc.net/problem/4256
- 🏷️ 분류: 트리 순회, 재귀(분할 정복), 구현

---

## 📌 문제 요약
각 테스트 케이스마다

- 전위 순회(preorder)
- 중위 순회(inorder)

결과가 주어질 때, 해당 트리의 **후위 순회(postorder)** 결과를 출력한다.

트리의 노드 값은 중복되지 않는다.

---

## 💡 풀이 아이디어 (분할 정복)
트리 순회의 성질을 이용한다.

- **전위 순회(preorder)**: `부모 → 왼쪽 → 오른쪽`
  - 따라서 어떤 (부분)트리의 루트는 preorder에서 **가장 앞**에 있다.
- **중위 순회(inorder)**: `왼쪽 → 부모 → 오른쪽`
  - 루트를 기준으로 inorder를 나누면
    - 왼쪽 구간 = 왼쪽 서브트리
    - 오른쪽 구간 = 오른쪽 서브트리

즉,
1) preorder의 첫 값으로 루트(부모)를 찾고  
2) inorder에서 루트 위치를 찾아 왼쪽/오른쪽 서브트리 크기를 계산한 뒤  
3) 같은 방식으로 재귀 호출해서 왼쪽, 오른쪽을 처리하고  
4) 마지막에 루트를 출력하면 후위 순회(`왼쪽 → 오른쪽 → 부모`)가 된다.

---

## ✅ 재귀 함수 정의: `div(preP, inP, size)`
- `preP` : 현재 서브트리의 preorder 시작 인덱스
- `inP` : 현재 서브트리의 inorder 시작 인덱스
- `size` : 현재 서브트리의 노드 개수

### 처리 과정
1) 루트(부모) 찾기  
- `parent = preorder[preP]`

2) inorder에서 parent 위치를 찾기 → 왼쪽 크기 계산  
- inorder 구간 `[inP .. inP+size-1]`에서 parent가 나올 때까지 이동  
- 그 이동 횟수 = `left` (왼쪽 서브트리 크기)
- 오른쪽 크기 = `right = size - 1 - left`

3) 왼쪽 서브트리 재귀  
- preorder는 루트 다음부터 왼쪽 크기만큼이 왼쪽 서브트리
- `div(preP + 1, inP, left)`

4) 오른쪽 서브트리 재귀  
- preorder에서 왼쪽을 건너뛴 다음이 오른쪽 서브트리 시작
- `div(preP + left + 1, inP + left + 1, right)`

5) 후위 순회이므로 마지막에 parent 출력  
- `print(parent)`

---

## 🧠 왜 마지막에 parent를 출력하면 후위 순회인가?
후위 순회는 `왼쪽 → 오른쪽 → 부모` 순서다.

재귀 호출로
- 왼쪽 서브트리 출력
- 오른쪽 서브트리 출력

을 먼저 수행한 후, 현재 루트를 출력하므로 자연스럽게 후위 순회가 된다.

---

## ⏱️ 복잡도
현재 구현은 각 재귀 단계에서 inorder에서 parent 위치를 찾기 위해 선형 탐색을 수행한다.

- 최악 시간 복잡도: `O(N^2)` (편향 트리일 때)
- 공간 복잡도: `O(N)` (재귀 스택)

> 개선(선택): inorder 값 → 인덱스를 미리 HashMap/배열에 저장하면  
> parent 위치 탐색이 `O(1)`이 되어 전체가 `O(N)`으로 줄어든다.

---

## 📝 구현 포인트(코드 기준)
- `left`와 `right`가 1 이상일 때만 재귀 호출하여 불필요 호출을 줄임
- 각 테스트 케이스마다 호출 후 줄바꿈 출력
- 출력은 공백으로 구분한 후위 순회 결과

---